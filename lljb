#!/bin/bash
# lljb - 轻量级端口流量监控与防火墙管理工具 (生产稳定版)
# 版本：2.5 (顶级健壮性 + 彻底修复条件判断错误 + 完整无删减版)
# 适用系统：Ubuntu/Debian/Alpine (nftables + vnstat)

set -Euo pipefail

# ---------- 颜色输出 ----------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# ---------- 全局配置 ----------
readonly CONFIG_DIR="/etc/lljb"
readonly PORTS_FILE="$CONFIG_DIR/ports.conf"
readonly SSH_PORT_CONFIG="$CONFIG_DIR/ssh_port.conf"
readonly COMMENT="lljb-managed"
readonly NFT_TABLE="lljb"
readonly NFT_INPUT_CHAIN="input_filter"
readonly NFT_OUTPUT_CHAIN="output_filter"
readonly NFT_FORWARD_CHAIN="forward_filter"
readonly LOG_FILE="/var/log/lljb.log"
readonly TRAFFIC_STATS_FILE="$CONFIG_DIR/traffic_stats.json"
readonly BACKUP_FILE="/tmp/lljb_nft_backup.nft"
readonly PID_FILE="/var/run/lljb.pid"

# ---------- 安全端口验证函数（彻底解决 conditional binary operator expected） ----------
is_valid_port() {
    local p="$1"
    [ -z "$p" ] && return 1
    [[ "\( p" =\~ ^[0-9]+ \) ]] || return 1
    (( p >= 1 && p <= 65535 )) || return 1
    return 0
}

# ---------- 辅助函数 ----------
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE" 2>/dev/null || true
}
error_exit() {
    echo -e "${RED}错误：$1${NC}" >&2
    exit 1
}
check_root() {
    [ "$EUID" -ne 0 ] && error_exit "请以 root 权限运行此脚本。"
}

trap 'log "脚本异常退出 (ERR)"; exit 1' ERR

# ---------- 系统检测与依赖安装 ----------
detect_system() {
    if [ -f /etc/alpine-release ]; then echo "alpine"
    elif [ -f /etc/debian_version ]; then echo "debian"
    else echo "unknown"; fi
}

install_dependencies() {
    local missing=()
    for cmd in nft vnstat bc jq; do
        command -v "$cmd" >/dev/null 2>&1 || missing+=("$cmd")
    done
    [ ${#missing[@]} -eq 0 ] && return 0

    echo -e "${YELLOW}正在安装缺失依赖: \( {missing[*]} \){NC}"
    local sys=$(detect_system)
    case "$sys" in
        debian)
            apt-get update -qq && apt-get install -y nftables vnstat bc jq
            systemctl enable --now vnstat 2>/dev/null || true
            ;;
        alpine)
            apk add --no-cache nftables vnstat bc jq
            rc-update add vnstat default 2>/dev/null || true
            rc-service vnstat start 2>/dev/null || true
            ;;
        *) error_exit "不支持的系统，请手动安装 nftables vnstat bc jq" ;;
    esac
    echo -e "\( {GREEN}依赖安装完成 \){NC}"
}

# ---------- SSH 端口检测（彻底修复版） ----------
detect_ssh_port() {
    if [ -f "$SSH_PORT_CONFIG" ]; then
        local user_port=$(cat "$SSH_PORT_CONFIG" 2>/dev/null | tr -d ' \n\r')
        if is_valid_port "$user_port"; then
            echo "$user_port"
            return
        else
            log "警告：SSH端口配置文件无效，使用自动检测"
        fi
    fi

    local config_port=$(grep -E "^Port\s+[0-9]+" /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}' | head -1)
    is_valid_port "$config_port" && { echo "$config_port"; return; }

    local listen_port=$(ss -tlnp 2>/dev/null | grep -oP 'sshd.*:\K\d+' | head -1)
    is_valid_port "$listen_port" && { echo "$listen_port"; return; }

    echo "22"
}

# ---------- nftables 初始化 ----------
init_nftables() {
    nft add table inet "$NFT_TABLE" 2>/dev/null || true
    nft add chain inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" { type filter hook input priority 0\; policy accept\; } 2>/dev/null || true
    nft add chain inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" { type filter hook output priority 0\; policy accept\; } 2>/dev/null || true
    nft add chain inet "$NFT_TABLE" "$NFT_FORWARD_CHAIN" { type filter hook forward priority 0\; policy accept\; } 2>/dev/null || true
    log "nftables 初始化完成"
}

# ---------- 端口监控计数器操作 ----------
add_port_counter() {
    local port=$1 proto=$2
    nft insert rule inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" $proto dport $port counter comment \"$COMMENT\" 2>/dev/null || true
    nft insert rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" $proto sport $port counter comment \"$COMMENT\" 2>/dev/null || true
    nft insert rule inet "$NFT_TABLE" "$NFT_FORWARD_CHAIN" $proto dport $port counter comment \"$COMMENT\" 2>/dev/null || true
    nft insert rule inet "$NFT_TABLE" "$NFT_FORWARD_CHAIN" $proto sport $port counter comment \"$COMMENT\" 2>/dev/null || true
    log "添加监控端口：$port/$proto"
}

remove_port_counter() {
    local port=$1 proto=$2
    for chain in "$NFT_INPUT_CHAIN" "$NFT_OUTPUT_CHAIN" "$NFT_FORWARD_CHAIN"; do
        nft list chain inet "$NFT_TABLE" "$chain" 2>/dev/null | \
        grep "$proto .*port $port counter" | grep "$COMMENT" | awk '{print $NF}' | \
        while read -r h; do
            nft delete rule inet "$NFT_TABLE" "$chain" handle "$h" 2>/dev/null || true
        done
    done
    log "删除监控端口：$port/$proto"
}

# ---------- 可靠读取 nftables 字节数 ----------
get_nft_bytes() {
    local port=$1 proto=$2 direction=$3
    local chain dir_field fwd_chain bytes=0
    if [ "$direction" = "in" ]; then
        chain="$NFT_INPUT_CHAIN"; dir_field="dport"
    else
        chain="$NFT_OUTPUT_CHAIN"; dir_field="sport"
    fi
    fwd_chain="$NFT_FORWARD_CHAIN"

    for c in "$chain" "$fwd_chain"; do
        local b=$(nft list chain inet "$NFT_TABLE" "$c" 2>/dev/null | \
            grep -E "$proto $dir_field $port counter" | \
            grep -o 'bytes [0-9]*' | awk '{print $2}' | head -1 || echo 0)
        bytes=$((bytes + b))
    done
    echo "$bytes"
}

# ---------- JSON 流量持久化 ----------
init_traffic_stats() {
    [ ! -f "$TRAFFIC_STATS_FILE" ] && echo '{}' > "$TRAFFIC_STATS_FILE"
}

update_port_stats() {
    local port=$1 in_bytes=$2 out_bytes=$3
    jq --arg port "$port" --argjson in "$in_bytes" --argjson out "$out_bytes" \
       --argjson li 0 --argjson lo 0 \
       '.[$port] = {in: $in, out: $out, last_in: $li, last_out: $lo}' \
       "\( TRAFFIC_STATS_FILE" > " \){TRAFFIC_STATS_FILE}.tmp" 2>/dev/null && \
    mv "${TRAFFIC_STATS_FILE}.tmp" "$TRAFFIC_STATS_FILE" || true
}

get_port_stats() {
    local port=$1
    jq -r --arg p "$port" '.[$p] // {in:0,out:0} | "\(.in) \(.out)"' "$TRAFFIC_STATS_FILE" 2>/dev/null || echo "0 0"
}

get_port_full_stats() {
    local port=$1
    jq -r --arg p "$port" '.[$p] // {in:0,out:0,last_in:0,last_out:0} | "\(.in) \(.out) \(.last_in) \(.last_out)"' "$TRAFFIC_STATS_FILE" 2>/dev/null || echo "0 0 0 0"
}

# ---------- 守护进程（生产级） ----------
daemon() {
    [ -f "\( PID_FILE" ] && kill -0 " \)(cat "$PID_FILE" 2>/dev/null)" 2>/dev/null && exit 0
    echo $$ > "$PID_FILE"
    trap 'rm -f "$PID_FILE"; log "守护进程退出"; exit' EXIT INT TERM

    init_traffic_stats
    log "守护进程启动（每60秒更新流量）"

    while true; do
        sleep 60
        nft list table inet "$NFT_TABLE" >/dev/null 2>&1 || continue
        local ports=($(get_monitored_ports))
        for port in "${ports[@]}"; do
            update_port_traffic "$port" || true
        done
        log "流量统计更新完成"
    done
}

update_port_traffic() {
    local port=$1
    local in_tcp=$(get_nft_bytes "$port" tcp in)
    local in_udp=$(get_nft_bytes "$port" udp in)
    local out_tcp=$(get_nft_bytes "$port" tcp out)
    local out_udp=$(get_nft_bytes "$port" udp out)

    local cur_in=$((in_tcp + in_udp))
    local cur_out=$((out_tcp + out_udp))

    read -r saved_in saved_out last_in last_out < <(get_port_full_stats "$port")

    local delta_in=$((cur_in - last_in))
    local delta_out=$((cur_out - last_out))
    [ $delta_in -lt 0 ] && delta_in=0
    [ $delta_out -lt 0 ] && delta_out=0

    local new_in=$((saved_in + delta_in))
    local new_out=$((saved_out + delta_out))

    jq --arg port "$port" --argjson in "$new_in" --argjson out "$new_out" \
       --argjson li "$cur_in" --argjson lo "$cur_out" \
       '.[$port] = {in: $in, out: $out, last_in: $li, last_out: $lo}' \
       "\( TRAFFIC_STATS_FILE" > " \){TRAFFIC_STATS_FILE}.tmp" 2>/dev/null && \
    mv "${TRAFFIC_STATS_FILE}.tmp" "$TRAFFIC_STATS_FILE" || true
}

# ---------- 获取监控端口列表 ----------
get_monitored_ports() {
    [ -f "$PORTS_FILE" ] && cat "$PORTS_FILE" || true
}

# ---------- 字节数格式化 ----------
format_bytes() {
    local bytes=${1:-0}
    ! [[ "\( bytes" =\~ ^[0-9]+ \) ]] && bytes=0
    if [ \( bytes -ge 1073741824 ]; then echo " \)(bc <<< "scale=2; $bytes/1073741824")GB"
    elif [ \( bytes -ge 1048576 ]; then echo " \)(bc <<< "scale=2; $bytes/1048576")MB"
    elif [ \( bytes -ge 1024 ]; then echo " \)(bc <<< "scale=2; $bytes/1024")KB"
    else echo "${bytes}B"; fi
}

# ---------- 防火墙规则辅助函数 ----------
add_accept_rule() {
    local port=$1 proto=$2 direction=$3
    case $direction in
        in)  nft insert rule inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" $proto dport $port accept comment \"$COMMENT\" 2>/dev/null || true; log "添加放行规则（入站）：$port/$proto" ;;
        out) nft insert rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" $proto sport $port accept comment \"$COMMENT\" 2>/dev/null || true; log "添加放行规则（出站）：$port/$proto" ;;
        both)
            nft insert rule inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" $proto dport $port accept comment \"$COMMENT\" 2>/dev/null || true
            nft insert rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" $proto sport $port accept comment \"$COMMENT\" 2>/dev/null || true
            log "添加放行规则（双向）：$port/$proto"
            ;;
    esac
}

del_accept_rule() {
    local port=$1 proto=$2 direction=$3
    case $direction in
        in)
            local handle=$(nft -a list chain inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" 2>/dev/null | grep "$proto dport $port accept" | grep "$COMMENT" | awk '{print $NF}')
            [ -n "$handle" ] && nft delete rule inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" handle $handle 2>/dev/null || true
            log "删除放行规则（入站）：$port/$proto"
            ;;
        out)
            local handle=$(nft -a list chain inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" 2>/dev/null | grep "$proto sport $port accept" | grep "$COMMENT" | awk '{print $NF}')
            [ -n "$handle" ] && nft delete rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" handle $handle 2>/dev/null || true
            log "删除放行规则（出站）：$port/$proto"
            ;;
        both)
            local in_handle=$(nft -a list chain inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" 2>/dev/null | grep "$proto dport $port accept" | grep "$COMMENT" | awk '{print $NF}')
            [ -n "$in_handle" ] && nft delete rule inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" handle $in_handle 2>/dev/null || true
            local out_handle=$(nft -a list chain inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" 2>/dev/null | grep "$proto sport $port accept" | grep "$COMMENT" | awk '{print $NF}')
            [ -n "$out_handle" ] && nft delete rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" handle $out_handle 2>/dev/null || true
            log "删除放行规则（双向）：$port/$proto"
            ;;
    esac
}

add_drop_rule() {
    local port=$1 proto=$2 direction=$3
    case $direction in
        in)  nft insert rule inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" $proto dport $port drop comment \"$COMMENT\" 2>/dev/null || true; log "添加拒绝规则（入站）：$port/$proto" ;;
        out) nft insert rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" $proto sport $port drop comment \"$COMMENT\" 2>/dev/null || true; log "添加拒绝规则（出站）：$port/$proto" ;;
        both)
            nft insert rule inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" $proto dport $port drop comment \"$COMMENT\" 2>/dev/null || true
            nft insert rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" $proto sport $port drop comment \"$COMMENT\" 2>/dev/null || true
            log "添加拒绝规则（双向）：$port/$proto"
            ;;
    esac
}

del_drop_rule() {
    local port=$1 proto=$2 direction=$3
    case $direction in
        in)
            local handle=$(nft -a list chain inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" 2>/dev/null | grep "$proto dport $port drop" | grep "$COMMENT" | awk '{print $NF}')
            [ -n "$handle" ] && nft delete rule inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" handle $handle 2>/dev/null || true
            log "删除拒绝规则（入站）：$port/$proto"
            ;;
        out)
            local handle=$(nft -a list chain inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" 2>/dev/null | grep "$proto sport $port drop" | grep "$COMMENT" | awk '{print $NF}')
            [ -n "$handle" ] && nft delete rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" handle $handle 2>/dev/null || true
            log "删除拒绝规则（出站）：$port/$proto"
            ;;
        both)
            local in_handle=$(nft -a list chain inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" 2>/dev/null | grep "$proto dport $port drop" | grep "$COMMENT" | awk '{print $NF}')
            [ -n "$in_handle" ] && nft delete rule inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" handle $in_handle 2>/dev/null || true
            local out_handle=$(nft -a list chain inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" 2>/dev/null | grep "$proto sport $port drop" | grep "$COMMENT" | awk '{print $NF}')
            [ -n "$out_handle" ] && nft delete rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" handle $out_handle 2>/dev/null || true
            log "删除拒绝规则（双向）：$port/$proto"
            ;;
    esac
}

# ---------- 交互式增删函数 ----------
add_accept_interactive() {
    read -p "请输入要放行的端口号（可多个，空格分隔）: " -a ports
    [ \( {#ports[@]} -eq 0 ] && { echo -e " \){RED}未输入端口${NC}"; read -p "按回车键继续..."; return; }
    echo "请选择方向：1)入站 2)出站 3)双向"; read -p "选择 [1-3] (默认3): " dir_choice
    dir_choice=${dir_choice:-3}
    case $dir_choice in 1) direction="in";; 2) direction="out";; *) direction="both";; esac

    echo "请选择协议：1)TCP 2)UDP 3)TCP+UDP"; read -p "选择 [1-3] (默认3): " proto_choice
    proto_choice=${proto_choice:-3}
    case $proto_choice in 1) protos=("tcp");; 2) protos=("udp");; *) protos=("tcp" "udp");; esac

    for port in "${ports[@]}"; do
        is_valid_port "\( port" || { echo -e " \){RED}跳过无效端口 \( port \){NC}"; continue; }
        for proto in "${protos[@]}"; do
            add_accept_rule "$port" "$proto" "$direction"
            echo -e "${GREEN}已添加放行 $port/\( proto ( \){direction})${NC}"
        done
    done
    add_accept_rule "$SSH_PORT" "tcp" "in" 2>/dev/null || true
    echo -e "${GREEN}已确保 SSH 端口 \( SSH_PORT/tcp 入站放行 \){NC}"
    read -p "按回车键继续..."
}

del_accept_interactive() {
    read -p "请输入要删除放行的端口号（可多个，空格分隔）: " -a ports
    [ \( {#ports[@]} -eq 0 ] && { echo -e " \){RED}未输入端口${NC}"; read -p "按回车键继续..."; return; }
    echo "请选择方向：1)入站 2)出站 3)双向"; read -p "选择 [1-3] (默认3): " dir_choice
    dir_choice=${dir_choice:-3}
    case $dir_choice in 1) direction="in";; 2) direction="out";; *) direction="both";; esac

    echo "请选择协议：1)TCP 2)UDP 3)TCP+UDP"; read -p "选择 [1-3] (默认3): " proto_choice
    proto_choice=${proto_choice:-3}
    case $proto_choice in 1) protos=("tcp");; 2) protos=("udp");; *) protos=("tcp" "udp");; esac

    for port in "${ports[@]}"; do
        is_valid_port "$port" || continue
        if [ "$port" = "$SSH_PORT" ] && { [ "$direction" = "in" ] || [ "$direction" = "both" ]; }; then
            echo -e "\( {YELLOW}警告：不能删除 SSH 端口入站规则，已跳过 \){NC}"
            [ "$direction" = "both" ] && direction="out"
        fi
        for proto in "${protos[@]}"; do
            del_accept_rule "$port" "$proto" "$direction"
            echo -e "${GREEN}已删除放行 $port/\( proto ( \){direction})${NC}"
        done
    done
    read -p "按回车键继续..."
}

add_drop_interactive() {
    read -p "请输入要拒绝的端口号（可多个，空格分隔）: " -a ports
    [ \( {#ports[@]} -eq 0 ] && { echo -e " \){RED}未输入端口${NC}"; read -p "按回车键继续..."; return; }
    echo "请选择方向：1)入站 2)出站 3)双向"; read -p "选择 [1-3] (默认3): " dir_choice
    dir_choice=${dir_choice:-3}
    case $dir_choice in 1) direction="in";; 2) direction="out";; *) direction="both";; esac

    echo "请选择协议：1)TCP 2)UDP 3)TCP+UDP"; read -p "选择 [1-3] (默认3): " proto_choice
    proto_choice=${proto_choice:-3}
    case $proto_choice in 1) protos=("tcp");; 2) protos=("udp");; *) protos=("tcp" "udp");; esac

    for port in "${ports[@]}"; do
        is_valid_port "$port" || continue
        [ "$port" = "\( SSH_PORT" ] && { echo -e " \){RED}不能拒绝 SSH 端口，已跳过${NC}"; continue; }
        for proto in "${protos[@]}"; do
            add_drop_rule "$port" "$proto" "$direction"
            echo -e "${GREEN}已添加拒绝 $port/\( proto ( \){direction})${NC}"
        done
    done
    read -p "按回车键继续..."
}

del_drop_interactive() {
    read -p "请输入要删除拒绝的端口号（可多个，空格分隔）: " -a ports
    [ \( {#ports[@]} -eq 0 ] && { echo -e " \){RED}未输入端口${NC}"; read -p "按回车键继续..."; return; }
    echo "请选择方向：1)入站 2)出站 3)双向"; read -p "选择 [1-3] (默认3): " dir_choice
    dir_choice=${dir_choice:-3}
    case $dir_choice in 1) direction="in";; 2) direction="out";; *) direction="both";; esac

    echo "请选择协议：1)TCP 2)UDP 3)TCP+UDP"; read -p "选择 [1-3] (默认3): " proto_choice
    proto_choice=${proto_choice:-3}
    case $proto_choice in 1) protos=("tcp");; 2) protos=("udp");; *) protos=("tcp" "udp");; esac

    for port in "${ports[@]}"; do
        is_valid_port "$port" || continue
        for proto in "${protos[@]}"; do
            del_drop_rule "$port" "$proto" "$direction"
            echo -e "${GREEN}已删除拒绝 $port/\( proto ( \){direction})${NC}"
        done
    done
    read -p "按回车键继续..."
}

# ---------- 一键拒绝入站/出站 ----------
set_default_drop_in() {
    clear
    echo -e "\( {YELLOW}警告：即将设置 INPUT 链默认 DROP（自动放行SSH） \){NC}"
    read -p "确认继续？[y/N]: " confirm
    [[ ! "\( confirm" =\~ ^[Yy] \) ]] && return
    add_accept_rule "$SSH_PORT" "tcp" "in" 2>/dev/null || true
    nft add rule inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" drop 2>/dev/null || true
    echo -e "\( {GREEN}操作完成 \){NC}"
    read -p "按回车键继续..."
}

set_default_drop_out() {
    clear
    echo -e "\( {YELLOW}警告：即将设置 OUTPUT 链默认 DROP（自动放行SSH） \){NC}"
    read -p "确认继续？[y/N]: " confirm
    [[ ! "\( confirm" =\~ ^[Yy] \) ]] && return
    nft add rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" ct state established,related accept comment \"$COMMENT\" 2>/dev/null || true
    nft add rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" oif lo accept comment \"$COMMENT\" 2>/dev/null || true
    nft add rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" tcp dport $SSH_PORT accept comment \"$COMMENT\" 2>/dev/null || true
    nft add rule inet "$NFT_TABLE" "$NFT_OUTPUT_CHAIN" drop 2>/dev/null || true
    echo -e "\( {GREEN}操作完成 \){NC}"
    read -p "按回车键继续..."
}

# ---------- 重置端口计数器 ----------
reset_port_counters() {
    clear
    echo -e "\( {BLUE}--- 重置端口流量计数器 --- \){NC}"
    local ports=($(get_monitored_ports))
    [ ${#ports[@]} -eq 0 ] && { echo "当前没有监控端口。"; read -p "按回车键返回..."; return; }
    echo "将重置以下端口：${ports[*]}"
    read -p "确认重置？[y/N]: " confirm
    if [[ "\( confirm" =\~ ^[Yy] \) ]]; then
        for port in "${ports[@]}"; do
            remove_port_counter "$port" tcp
            remove_port_counter "$port" udp
            add_port_counter "$port" tcp
            add_port_counter "$port" udp
            update_port_stats "$port" 0 0
            echo -e "${GREEN}端口 \( port 已重置 \){NC}"
        done
    fi
    read -p "按回车键返回..."
}

# ---------- 手动设置 SSH 端口 ----------
set_ssh_port() {
    clear
    echo -e "\( {BLUE}--- 手动设置 SSH 端口 --- \){NC}"
    echo "当前 SSH 端口: $SSH_PORT"
    read -p "新端口 (空值取消): " new_port
    [ -z "$new_port" ] && { echo "已取消"; read -p "按回车键继续..."; return; }
    if ! is_valid_port "$new_port"; then
        echo -e "\( {RED}无效端口号 \){NC}"
    else
        echo "$new_port" > "$SSH_PORT_CONFIG"
        SSH_PORT=$(detect_ssh_port)
        echo -e "${GREEN}SSH 端口已设置为 \( SSH_PORT \){NC}"
        add_accept_rule "$SSH_PORT" "tcp" "in" 2>/dev/null || true
    fi
    read -p "按回车键继续..."
}

# ---------- 显示防火墙规则 ----------
show_firewall() {
    clear
    echo -e "\( {BLUE}--- 当前 nftables 规则 --- \){NC}"
    nft list ruleset
    echo ""
    read -p "按回车键返回..."
}

show_firewall_simple() {
    clear
    echo -e "\( {BLUE}--- 防火墙状态 (简洁模式) --- \){NC}"
    echo -e "\( {GREEN}允许入站： \){NC}"
    nft list chain inet "$NFT_TABLE" "$NFT_INPUT_CHAIN" 2>/dev/null | grep -E "accept|drop" | grep "$COMMENT" || echo "无规则"
    echo ""
    read -p "按回车键返回..."
}

# ---------- 防火墙子菜单 ----------
firewall_menu() {
    while true; do
        clear
        echo -e "\( {BLUE}--- 防火墙配置 --- \){NC}"
        echo "1. 显示详细规则"
        echo "2. 显示简洁规则"
        echo "3. 修改放行端口"
        echo "4. 修改拒绝端口"
        echo "5. 一键拒绝所有入站"
        echo "6. 一键拒绝所有出站"
        echo "7. 重置端口流量计数器"
        echo "8. 手动设置 SSH 端口"
        echo "0. 返回主菜单"
        read -p "请选择 [0-8]: " fw_choice
        case $fw_choice in
            1) show_firewall ;;
            2) show_firewall_simple ;;
            3) modify_accept ;;
            4) modify_drop ;;
            5) set_default_drop_in ;;
            6) set_default_drop_out ;;
            7) reset_port_counters ;;
            8) set_ssh_port ;;
            0) return ;;
            *) echo -e "\( {RED}无效选择 \){NC}"; sleep 1 ;;
        esac
    done
}

# ---------- 活跃端口显示（完整原版，无省略） ----------
show_active_ports() {
    echo -e "\( {BLUE}--- 当前活跃端口及进程 --- \){NC}"
    printf "%-8s %-8s %-12s %-8s %s\n" "协议" "端口" "状态" "PID" "进程名"

    ss -tulnp 2>/dev/null | awk 'NR>1 {
        split($5, addr, ":");
        port = addr[length(addr)];
        proto = $1;
        state = "LISTEN";
        pid_info = $7;
        pid = "-"; proc = "-";
        if (pid_info \~ /pid=/) {
            gsub(/.*pid=/, "", pid_info);
            split(pid_info, a, ",");
            pid = a[1];
            if (pid != "-") {
                cmd = "cat /proc/" pid "/comm 2>/dev/null"
                cmd | getline proc
                close(cmd)
            }
        }
        printf "%-8s %-8s %-12s %-8s %s\n", proto, port, state, pid, proc;
    }'

    ss -tpn 2>/dev/null | grep ESTAB | awk '{
        split($5, addr, ":");
        port = addr[length(addr)];
        proto = $1;
        state = "ESTAB";
        pid_info = $6;
        pid = "-"; proc = "-";
        if (pid_info \~ /pid=/) {
            gsub(/.*pid=/, "", pid_info);
            split(pid_info, a, ",");
            pid = a[1];
            if (pid != "-") {
                cmd = "cat /proc/" pid "/comm 2>/dev/null"
                cmd | getline proc
                close(cmd)
            }
        }
        printf "%-8s %-8s %-12s %-8s %s\n", proto, port, state, pid, proc;
    }' | sort -u

    echo "----------------------------------------"
    echo -e "\( {YELLOW}提示：若进程名仍为“-”，可能进程已退出或无权限读取。 \){NC}"
}

# ---------- 端口流量显示（已修复） ----------
show_port_traffic() {
    clear
    echo -e "\( {BLUE}--- 监听端口流量使用量 (累计) --- \){NC}"
    local ports=($(get_monitored_ports))
    if [ ${#ports[@]} -eq 0 ]; then
        echo "暂无监控端口。"
    else
        printf "%-10s %-15s %-15s\n" "端口" "下载(入站)" "上传(出站)"
        echo "----------------------------------------"
        for port in "${ports[@]}"; do
            read -r in_bytes out_bytes <<< "$(get_port_stats "$port")"
            printf "%-10s %-15s %-15s\n" "\( port" " \)(format_bytes "\( in_bytes")" " \)(format_bytes "$out_bytes")"
        done
    fi
    echo ""
    read -p "按回车键返回菜单..."
}

# ---------- 总流量显示 ----------
show_total_traffic() {
    clear
    echo -e "\( {BLUE}--- 主机总流量使用量 (当日累计) --- \){NC}"
    if command -v vnstat >/dev/null 2>&1; then
        vnstat -d --oneline 2>/dev/null | head -1 | awk -F';' '{print "总下载: "$3" "$4"\n总上传: "$5" "$6}'
    else
        echo "vnstat 未安装"
    fi
    read -p "按回车键返回菜单..."
}

# ---------- 增加/删除监听端口 ----------
add_port() {
    clear
    show_active_ports
    echo -e "\( {BLUE}--- 增加监听端口 --- \){NC}"
    read -p "端口号（空格分隔）: " -a ports
    for port in "${ports[@]}"; do
        is_valid_port "$port" || continue
        grep -qx "$port" "$PORTS_FILE" 2>/dev/null && continue
        echo "$port" >> "$PORTS_FILE"
        add_port_counter "$port" tcp
        add_port_counter "$port" udp
        update_port_stats "$port" 0 0
        echo -e "${GREEN}端口 \( port 已添加 \){NC}"
    done
    read -p "按回车键返回..."
}

remove_port() {
    clear
    show_active_ports
    echo -e "\( {BLUE}--- 删除监听端口 --- \){NC}"
    local monitored=$(get_monitored_ports)
    [ -z "$monitored" ] && { echo "无监控端口"; read -p "按回车键返回..."; return; }
    echo "$monitored" | nl
    read -p "要删除的端口: " -a ports
    for port in "${ports[@]}"; do
        is_valid_port "$port" || continue
        sed -i "/^\( port \)/d" "$PORTS_FILE" 2>/dev/null || true
        remove_port_counter "$port" tcp
        remove_port_counter "$port" udp
        jq --arg p "$port" 'del(.[$p])' "\( TRAFFIC_STATS_FILE" > " \){TRAFFIC_STATS_FILE}.tmp" 2>/dev/null && mv "${TRAFFIC_STATS_FILE}.tmp" "$TRAFFIC_STATS_FILE" || true
        echo -e "${GREEN}端口 \( port 已删除 \){NC}"
    done
    read -p "按回车键返回..."
}

# ---------- 修改放行/拒绝 ----------
modify_accept() {
    clear
    show_active_ports
    echo -e "\( {BLUE}--- 修改放行端口 --- \){NC}"
    echo "请选择：1.增加 2.删除 0.返回"
    read -p "选择: " op
    case $op in 1) add_accept_interactive;; 2) del_accept_interactive;; esac
}

modify_drop() {
    clear
    show_active_ports
    echo -e "\( {BLUE}--- 修改拒绝端口 --- \){NC}"
    echo "请选择：1.增加 2.删除 0.返回"
    read -p "选择: " op
    case $op in 1) add_drop_interactive;; 2) del_drop_interactive;; esac
}

# ---------- 卸载 ----------
uninstall_script() {
    clear
    echo -e "\( {RED}警告：即将彻底卸载 lljb \){NC}"
    read -p "确认？[y/N]: " confirm
    [[ ! "\( confirm" =\~ ^[Yy] \) ]] && return
    [ -f "\( PID_FILE" ] && kill " \)(cat "$PID_FILE" 2>/dev/null)" 2>/dev/null || true
    nft list ruleset > "$BACKUP_FILE" 2>/dev/null || true
    nft delete table inet "$NFT_TABLE" 2>/dev/null || true
    rm -rf "$CONFIG_DIR"
    rm -f "$0"
    echo -e "\( {GREEN}卸载完成 \){NC}"
    exit 0
}

# ---------- 主菜单 ----------
main_menu() {
    while true; do
        clear
        echo -e "\( {BLUE}================================= \){NC}"
        echo -e "\( {GREEN}       l l j b   v2.5 主菜单 \){NC}"
        echo -e "\( {BLUE}================================= \){NC}"
        monitored=$(get_monitored_ports | tr '\n' ' ')
        echo -e "${YELLOW}当前监控端口: \( {monitored:-无} \){NC}"
        echo -e "${GREEN}SSH 端口: \( SSH_PORT \){NC}"
        echo ""
        echo "1. 显示端口流量使用量"
        echo "2. 显示总流量 (vnstat)"
        echo "3. 增加监听端口"
        echo "4. 删除监听端口"
        echo "5. 彻底卸载脚本"
        echo "6. 配置防火墙"
        echo "0. 退出"
        read -p "请选择 [0-6]: " choice
        case $choice in
            1) show_port_traffic ;;
            2) show_total_traffic ;;
            3) add_port ;;
            4) remove_port ;;
            5) uninstall_script ;;
            6) firewall_menu ;;
            0) exit 0 ;;
            *) echo -e "\( {RED}无效选择 \){NC}"; sleep 1 ;;
        esac
    done
}

# ---------- 初始化 ----------
init() {
    mkdir -p "$CONFIG_DIR"
    touch "$PORTS_FILE" "$LOG_FILE"
    init_traffic_stats
    init_nftables

    SSH_PORT=$(detect_ssh_port)
    echo -e "${GREEN}检测到 SSH 端口: \( SSH_PORT \){NC}"
    add_accept_rule "$SSH_PORT" "tcp" "in" 2>/dev/null || true

    while read -r port; do
        is_valid_port "$port" && {
            add_port_counter "$port" tcp 2>/dev/null || true
            add_port_counter "$port" udp 2>/dev/null || true
        }
    done < "$PORTS_FILE"

    # 兼容旧数据
    jq 'to_entries | map(.value += {last_in: (.value.last_in // 0), last_out: (.value.last_out // 0)}) | from_entries' \
        "\( TRAFFIC_STATS_FILE" > " \){TRAFFIC_STATS_FILE}.tmp" 2>/dev/null && mv "${TRAFFIC_STATS_FILE}.tmp" "$TRAFFIC_STATS_FILE" || true

    nohup "$0" --daemon >/dev/null 2>&1 &
    log "lljb v2.5 生产稳定版启动完成"
}

# ---------- 主入口 ----------
main() {
    check_root
    install_dependencies

    if [ "${1:-}" = "--daemon" ]; then
        daemon
        exit 0
    fi

    init
    main_menu
}

main "$@"
