#!/bin/bash
# lljb - 轻量级端口流量监控与防火墙管理工具
# 版本：1.1 (新增一键拒绝入站/出站功能)
# 作者：Assistant

set -euo pipefail

# ---------- 全局配置 ----------
readonly SCRIPT_NAME="lljb"
readonly CONFIG_DIR="/etc/lljb"
readonly PORTS_FILE="$CONFIG_DIR/ports.conf"
readonly TRAFFIC_FILE="$CONFIG_DIR/traffic.db"
readonly LAST_COUNTER_FILE="$CONFIG_DIR/last_counter"
readonly PID_FILE="/var/run/lljb.pid"
readonly LOG_FILE="/var/log/lljb.log"
readonly COMMENT="lljb-managed"
readonly DAEMON_INTERVAL=30  # 轮询间隔（秒）

# ---------- 颜色输出 ----------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# ---------- 辅助函数 ----------
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

error_exit() {
    echo -e "${RED}错误：$1${NC}" >&2
    exit 1
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        error_exit "请以 root 权限运行此脚本。"
    fi
}

init_config() {
    mkdir -p "$CONFIG_DIR"
    touch "$PORTS_FILE" "$TRAFFIC_FILE" "$LAST_COUNTER_FILE" "$LOG_FILE"
}

# 获取 SSH 端口（从配置文件或默认22）
get_ssh_port() {
    local ssh_port=$(grep -E "^Port\s+" /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}' | head -1)
    echo "${ssh_port:-22}"
}

# ---------- iptables 操作 ----------
create_custom_chains() {
    # 创建自定义链（如果不存在）
    if ! iptables -L TRAFFIC_IN >/dev/null 2>&1; then
        iptables -N TRAFFIC_IN
        iptables -I INPUT -j TRAFFIC_IN
    fi
    if ! iptables -L TRAFFIC_OUT >/dev/null 2>&1; then
        iptables -N TRAFFIC_OUT
        iptables -I OUTPUT -j TRAFFIC_OUT
    fi
}

delete_custom_chains() {
    iptables -D INPUT -j TRAFFIC_IN 2>/dev/null || true
    iptables -D OUTPUT -j TRAFFIC_OUT 2>/dev/null || true
    iptables -F TRAFFIC_IN 2>/dev/null || true
    iptables -F TRAFFIC_OUT 2>/dev/null || true
    iptables -X TRAFFIC_IN 2>/dev/null || true
    iptables -X TRAFFIC_OUT 2>/dev/null || true
}

# 添加监控端口规则（只计数，不干预）
add_monitor_rule() {
    local port=$1
    local proto=$2
    iptables -A TRAFFIC_IN -p $proto --dport $port -m comment --comment "$COMMENT"
    iptables -A TRAFFIC_OUT -p $proto --sport $port -m comment --comment "$COMMENT"
    log "添加监控端口：$port/$proto"
}

remove_monitor_rule() {
    local port=$1
    local proto=$2
    iptables -D TRAFFIC_IN -p $proto --dport $port -m comment --comment "$COMMENT" 2>/dev/null || true
    iptables -D TRAFFIC_OUT -p $proto --sport $port -m comment --comment "$COMMENT" 2>/dev/null || true
    log "删除监控端口：$port/$proto"
}

# 获取所有监控端口列表（从配置文件）
get_monitored_ports() {
    if [ -f "$PORTS_FILE" ]; then
        cat "$PORTS_FILE"
    fi
}

# 获取所有端口的当前原始计数（字节）
get_raw_counters() {
    iptables -L TRAFFIC_IN -v -n -x | awk -v comment="$COMMENT" '
        $0 ~ comment {
            if ($4 == "tcp" || $4 == "udp") {
                proto = $4
                for (i=1; i<=NF; i++) {
                    if ($i == "--dport") {
                        port = $(i+1)
                        break
                    }
                }
                if (port != "") print proto":in:"port":"$2
            }
        }
    '
    iptables -L TRAFFIC_OUT -v -n -x | awk -v comment="$COMMENT" '
        $0 ~ comment {
            if ($4 == "tcp" || $4 == "udp") {
                proto = $4
                for (i=1; i<=NF; i++) {
                    if ($i == "--sport") {
                        port = $(i+1)
                        break
                    }
                }
                if (port != "") print proto":out:"port":"$2
            }
        }
    '
}

# 字节数格式化
format_bytes() {
    local bytes=$1
    if [ $bytes -ge 1073741824 ]; then
        echo "$(echo "scale=2; $bytes/1073741824" | bc)GB"
    elif [ $bytes -ge 1048576 ]; then
        echo "$(echo "scale=2; $bytes/1048576" | bc)MB"
    elif [ $bytes -ge 1024 ]; then
        echo "$(echo "scale=2; $bytes/1024" | bc)KB"
    else
        echo "${bytes}B"
    fi
}

# 获取当天0点的时间戳（秒）
get_today_midnight() {
    date -d "0:00" +%s
}

# ---------- 守护进程 ----------
daemon() {
    if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null; then
        exit 0
    fi
    echo $$ > "$PID_FILE"
    trap 'rm -f "$PID_FILE"; exit' EXIT INT TERM

    init_config
    create_custom_chains

    while read -r port; do
        [ -z "$port" ] && continue
        add_monitor_rule "$port" tcp
        add_monitor_rule "$port" udp
    done < "$PORTS_FILE"

    if [ ! -s "$LAST_COUNTER_FILE" ]; then
        get_raw_counters > "$LAST_COUNTER_FILE"
        echo "TIMESTAMP=$(date +%s)" >> "$LAST_COUNTER_FILE"
        > "$TRAFFIC_FILE"
    fi

    while true; do
        sleep $DAEMON_INTERVAL

        if [ -f "$LAST_COUNTER_FILE" ]; then
            eval $(grep -E "^TIMESTAMP=" "$LAST_COUNTER_FILE")
            last_ts=${TIMESTAMP:-0}
            cp "$LAST_COUNTER_FILE" "${LAST_COUNTER_FILE}.old"
        else
            continue
        fi

        current_raw=$(get_raw_counters)
        current_ts=$(date +%s)

        if [ $(date -d @$last_ts +%Y%m%d) != $(date -d @$current_ts +%Y%m%d) ]; then
            > "$TRAFFIC_FILE"
            echo "$current_raw" > "$LAST_COUNTER_FILE"
            echo "TIMESTAMP=$current_ts" >> "$LAST_COUNTER_FILE"
            continue
        fi

        declare -A current_in current_out
        while IFS=: read -r proto dir port bytes; do
            if [ "$dir" = "in" ]; then
                current_in["$proto:$port"]=$bytes
            else
                current_out["$proto:$port"]=$bytes
            fi
        done <<< "$current_raw"

        declare -A last_in last_out
        while IFS=: read -r proto dir port bytes; do
            if [ "$dir" = "in" ]; then
                last_in["$proto:$port"]=$bytes
            else
                last_out["$proto:$port"]=$bytes
            fi
        done < <(grep -v "^TIMESTAMP=" "${LAST_COUNTER_FILE}.old")

        > "${TRAFFIC_FILE}.tmp"
        for key in "${!current_in[@]}"; do
            proto=${key%%:*}
            port=${key#*:}
            last_bytes=${last_in[$key]:-0}
            current_bytes=${current_in[$key]:-0}
            delta=$((current_bytes - last_bytes))
            if [ $delta -gt 0 ]; then
                old_total=$(grep "^${proto}:${port}:in:" "$TRAFFIC_FILE" | cut -d: -f4)
                old_total=${old_total:-0}
                new_total=$((old_total + delta))
                echo "${proto}:${port}:in:${new_total}" >> "${TRAFFIC_FILE}.tmp"
            fi
        done
        for key in "${!current_out[@]}"; do
            proto=${key%%:*}
            port=${key#*:}
            last_bytes=${last_out[$key]:-0}
            current_bytes=${current_out[$key]:-0}
            delta=$((current_bytes - last_bytes))
            if [ $delta -gt 0 ]; then
                old_total=$(grep "^${proto}:${port}:out:" "$TRAFFIC_FILE" | cut -d: -f4)
                old_total=${old_total:-0}
                new_total=$((old_total + delta))
                echo "${proto}:${port}:out:${new_total}" >> "${TRAFFIC_FILE}.tmp"
            fi
        done

        if [ -s "${TRAFFIC_FILE}.tmp" ]; then
            cat "${TRAFFIC_FILE}.tmp" > "$TRAFFIC_FILE"
        fi
        rm -f "${TRAFFIC_FILE}.tmp"

        echo "$current_raw" > "$LAST_COUNTER_FILE"
        echo "TIMESTAMP=$current_ts" >> "$LAST_COUNTER_FILE"
        rm -f "${LAST_COUNTER_FILE}.old"
    done
}

# ---------- 菜单功能 ----------

# 显示主菜单
main_menu() {
    while true; do
        clear
        echo -e "${BLUE}=================================${NC}"
        echo -e "${GREEN}       l l j b   主菜单${NC}"
        echo -e "${BLUE}=================================${NC}"
        
        # ---------- 新增：显示监控端口 ----------
        monitored_ports=$(get_monitored_ports | tr '\n' ' ')
        if [ -n "$monitored_ports" ]; then
            echo -e "${YELLOW}当前监控端口:${NC} $monitored_ports"
        else
            echo -e "${YELLOW}当前监控端口:${NC} 无"
        fi
        echo ""
        # ---------------------------------------

        echo "1. 显示监听端口流量使用量"
        echo "2. 显示总流量使用量"
        echo "3. 增加监听端口"
        echo "4. 删除监听端口"
        echo "5. 彻底卸载脚本"
        echo "6. 配置防火墙"
        echo "0. 退出"
        echo -e "${BLUE}=================================${NC}"
        read -p "请选择 [0-6]: " choice
        case $choice in
            1) show_port_traffic ;;
            2) show_total_traffic ;;
            3) add_port ;;
            4) remove_port ;;
            5) uninstall_script ;;
            6) firewall_menu ;;
            0) exit 0 ;;
            *) echo -e "${RED}无效选择，请重试${NC}"; sleep 1 ;;
        esac
    done
}

# 显示单个端口流量
show_port_traffic() {
    clear
    echo -e "${BLUE}--- 监听端口流量使用量 (当日累计) ---${NC}"
    if [ ! -f "$TRAFFIC_FILE" ] || [ ! -s "$TRAFFIC_FILE" ]; then
        echo "暂无流量数据。"
    else
        printf "%-10s %-8s %-15s %-15s\n" "端口" "协议" "下载(入站)" "上传(出站)"
        echo "----------------------------------------"
        declare -A in_map out_map
        while IFS=: read -r proto dir port bytes; do
            if [ "$dir" = "in" ]; then
                in_map["$port:$proto"]=$bytes
            else
                out_map["$port:$proto"]=$bytes
            fi
        done < "$TRAFFIC_FILE"
        monitored=$(get_monitored_ports)
        all_ports=$(echo -e "$monitored\n${!in_map[@]}" | tr ' ' '\n' | sort -un)
        for entry in $all_ports; do
            if [[ "$entry" =~ ^[0-9]+$ ]]; then
                port=$entry
                for proto in tcp udp; do
                    in_bytes=${in_map["$port:$proto"]:-0}
                    out_bytes=${out_map["$port:$proto"]:-0}
                    if [ $in_bytes -gt 0 ] || [ $out_bytes -gt 0 ]; then
                        printf "%-10s %-8s %-15s %-15s\n" "$port" "$proto" "$(format_bytes $in_bytes)" "$(format_bytes $out_bytes)"
                    fi
                done
            else
                IFS=':' read -r port proto <<< "$entry"
                in_bytes=${in_map["$port:$proto"]:-0}
                out_bytes=${out_map["$port:$proto"]:-0}
                printf "%-10s %-8s %-15s %-15s\n" "$port" "$proto" "$(format_bytes $in_bytes)" "$(format_bytes $out_bytes)"
            fi
        done
    fi
    echo ""
    read -p "按回车键返回菜单..."
}

# 显示总流量
show_total_traffic() {
    clear
    echo -e "${BLUE}--- 总流量使用量 (当日累计) ---${NC}"
    total_in=0
    total_out=0
    if [ -f "$TRAFFIC_FILE" ]; then
        while IFS=: read -r proto dir port bytes; do
            if [ "$dir" = "in" ]; then
                total_in=$((total_in + bytes))
            else
                total_out=$((total_out + bytes))
            fi
        done < "$TRAFFIC_FILE"
    fi
    total=$((total_in + total_out))
    echo "总下载(入站): $(format_bytes $total_in)"
    echo "总上传(出站): $(format_bytes $total_out)"
    echo "总计: $(format_bytes $total)"
    echo ""
    read -p "按回车键返回菜单..."
}

# 增加监听端口
add_port() {
    clear
    echo -e "${BLUE}--- 增加监听端口 ---${NC}"
    read -p "请输入要监控的端口号（可多个，用空格分隔）: " -a ports
    if [ ${#ports[@]} -eq 0 ]; then
        echo -e "${RED}未输入端口${NC}"
        sleep 1
        return
    fi
    for port in "${ports[@]}"; do
        if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
            echo -e "${RED}跳过无效端口: $port${NC}"
            continue
        fi
        if grep -qx "$port" "$PORTS_FILE" 2>/dev/null; then
            echo -e "${YELLOW}端口 $port 已在监控列表中${NC}"
            continue
        fi
        echo "$port" >> "$PORTS_FILE"
        add_monitor_rule "$port" tcp
        add_monitor_rule "$port" udp
        echo -e "${GREEN}端口 $port 已添加监控${NC}"
    done
    echo ""
    read -p "按回车键返回菜单..."
}

# 删除监听端口
remove_port() {
    clear
    echo -e "${BLUE}--- 删除监听端口 ---${NC}"
    monitored=$(get_monitored_ports)
    if [ -z "$monitored" ]; then
        echo "当前没有监控任何端口。"
    else
        echo "当前监控端口:"
        echo "$monitored" | nl
        read -p "请输入要删除的端口号（可多个，用空格分隔）: " -a ports
        for port in "${ports[@]}"; do
            if grep -qx "$port" "$PORTS_FILE"; then
                sed -i "/^$port$/d" "$PORTS_FILE"
                remove_monitor_rule "$port" tcp
                remove_monitor_rule "$port" udp
                echo -e "${GREEN}端口 $port 已删除${NC}"
            else
                echo -e "${YELLOW}端口 $port 不在监控列表中${NC}"
            fi
        done
    fi
    echo ""
    read -p "按回车键返回菜单..."
}

# 防火墙子菜单（新增选项4和5）
firewall_menu() {
    while true; do
        clear
        echo -e "${BLUE}--- 防火墙配置 ---${NC}"
        echo "1. 显示当前防火墙状态 (详细模式)"
        echo "2. 显示当前防火墙状态 (简洁模式)"
        echo "3. 修改放行端口（增加/删除）"
        echo "4. 修改拒绝端口（增加/删除）"
        echo "5. 一键拒绝所有入站 (自动放行SSH端口)"
        echo "6. 一键拒绝所有出站 (自动放行SSH端口)"
        echo "0. 返回主菜单"
        read -p "请选择 [0-6]: " fw_choice
        case $fw_choice in
            1) show_firewall_detail ;;   # 调用详细模式
            2) show_firewall_simple ;;    # 调用简洁模式
            3) modify_accept ;;
            4) modify_drop ;;
            5) set_default_drop_in ;;
            6) set_default_drop_out ;;
            0) return ;;
            *) echo -e "${RED}无效选择${NC}"; sleep 1 ;;
        esac
    done
}

# 显示防火墙状态
show_firewall() {
    clear
    echo -e "${BLUE}--- 当前防火墙规则 (INPUT链) ---${NC}"
    iptables -L INPUT -v -n --line-numbers | head -20
    echo ""
    echo -e "${BLUE}--- 当前防火墙规则 (OUTPUT链) ---${NC}"
    iptables -L OUTPUT -v -n --line-numbers | head -20
    echo ""
    read -p "按回车键返回..."
}
# 简洁显示函数（类似 ufw 风格）
show_firewall_simple() {
    clear
    echo -e "${BLUE}--- 防火墙状态 (简洁模式) ---${NC}"

    local input_policy=$(iptables -L INPUT -n | head -1 | awk '{print $4}' | tr -d ')')
    local output_policy=$(iptables -L OUTPUT -n | head -1 | awk '{print $4}' | tr -d ')')
    local forward_policy=$(iptables -L FORWARD -n | head -1 | awk '{print $4}' | tr -d ')')

    echo -e "${GREEN}状态:${NC} 激活"
    echo -e "${GREEN}默认策略:${NC} 入站: ${YELLOW}$input_policy${NC}, 出站: ${YELLOW}$output_policy${NC}, 转发: ${YELLOW}$forward_policy${NC}"
    echo

    echo -e "${GREEN}允许入站规则:${NC}"
    printf "%-25s %-10s %-20s\n" "To" "Action" "From"
    echo "------------------------- ---------- --------------------"

    iptables-save | grep '^-A INPUT' | while read -r rule; do
        if ! echo "$rule" | grep -q -- '-j ACCEPT'; then
            continue
        fi
        local proto=""
        local dport=""
        local multiport=""
        local source="Anywhere"
        if [[ "$rule" =~ -s[[:space:]]+([^[:space:]]+) ]]; then
            source="${BASH_REMATCH[1]}"
        fi
        if [[ "$rule" =~ -m[[:space:]]+multiport[[:space:]]+--dports[[:space:]]+([0-9,:]+) ]]; then
            multiport="${BASH_REMATCH[1]}"
            if [[ "$rule" =~ -p[[:space:]]+([a-z]+) ]]; then
                proto="${BASH_REMATCH[1]}"
            else
                proto="tcp/udp"
            fi
            dport="$multiport"
        else
            if [[ "$rule" =~ -p[[:space:]]+([a-z]+) ]]; then
                proto="${BASH_REMATCH[1]}"
            fi
            if [[ "$rule" =~ --dport[[:space:]]+([0-9]+) ]]; then
                dport="${BASH_REMATCH[1]}"
            fi
        fi
        if [ -n "$proto" ] && [ -n "$dport" ]; then
            printf "%-25s %-10s %-20s\n" "${dport}/${proto}" "ALLOW" "$source"
        fi
    done

    echo
    echo -e "${GREEN}拒绝入站规则:${NC}"
    printf "%-25s %-10s %-20s\n" "To" "Action" "From"
    echo "------------------------- ---------- --------------------"

    iptables-save | grep '^-A INPUT' | while read -r rule; do
        if ! echo "$rule" | grep -q -- '-j DROP'; then
            continue
        fi
        local proto=""
        local dport=""
        local multiport=""
        local source="Anywhere"
        if [[ "$rule" =~ -s[[:space:]]+([^[:space:]]+) ]]; then
            source="${BASH_REMATCH[1]}"
        fi
        if [[ "$rule" =~ -m[[:space:]]+multiport[[:space:]]+--dports[[:space:]]+([0-9,:]+) ]]; then
            multiport="${BASH_REMATCH[1]}"
            if [[ "$rule" =~ -p[[:space:]]+([a-z]+) ]]; then
                proto="${BASH_REMATCH[1]}"
            else
                proto="tcp/udp"
            fi
            dport="$multiport"
        else
            if [[ "$rule" =~ -p[[:space:]]+([a-z]+) ]]; then
                proto="${BASH_REMATCH[1]}"
            fi
            if [[ "$rule" =~ --dport[[:space:]]+([0-9]+) ]]; then
                dport="${BASH_REMATCH[1]}"
            fi
        fi
        if [ -n "$proto" ] && [ -n "$dport" ]; then
            printf "%-25s %-10s %-20s\n" "${dport}/${proto}" "DENY" "$source"
        fi
    done

    echo
    echo -e "${YELLOW}提示：仅显示 TCP/UDP 端口规则，复杂规则可能未完全列出。${NC}"
    echo ""
    read -p "按回车键返回..."
}

# 修改放行端口
modify_accept() {
    clear
    echo -e "${BLUE}--- 修改放行端口 ---${NC}"
    echo "当前放行规则（包含 ACCEPT）："
    iptables -L INPUT -v -n --line-numbers | grep ACCEPT | grep -E -- 'dpt:|spt:' || echo "无放行规则"
    echo ""
    echo "请选择操作："
    echo "1. 增加放行端口"
    echo "2. 删除放行端口"
    echo "0. 返回"
    read -p "选择: " op
    case $op in
        1) add_accept ;;
        2) del_accept ;;
        0) return ;;
        *) echo -e "${RED}无效选择${NC}"; sleep 1 ;;
    esac
}

add_accept() {
    read -p "请输入要放行的端口号（可多个，空格分隔）: " -a ports
    if [ ${#ports[@]} -eq 0 ]; then
        echo -e "${RED}未输入端口${NC}"
        read -p "按回车键继续..."
        return
    fi

    echo "请选择协议："
    echo "1) TCP  only"
    echo "2) UDP  only"
    echo "3) TCP+UDP (both)"
    read -p "选择 [1-3] (默认 3): " proto_choice
    proto_choice=${proto_choice:-3}

    case $proto_choice in
        1) protos=("tcp") ;;
        2) protos=("udp") ;;
        3) protos=("tcp" "udp") ;;
        *) echo -e "${RED}无效选择，默认使用 TCP+UDP${NC}"; protos=("tcp" "udp") ;;
    esac

    for port in "${ports[@]}"; do
        if ! [[ "$port" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}跳过无效端口 $port${NC}"
            continue
        fi
        for proto in "${protos[@]}"; do
            if iptables -C INPUT -p $proto --dport $port -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null; then
                echo -e "${YELLOW}端口 $port/$proto 已存在放行规则${NC}"
            else
                iptables -I INPUT -p $proto --dport $port -j ACCEPT -m comment --comment "$COMMENT"
                echo -e "${GREEN}已添加放行端口 $port/$proto${NC}"
            fi
        done
    done

    # 确保 SSH 端口放行（仅 TCP）
    ssh_port=$(get_ssh_port)
    iptables -C INPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null || \
        iptables -I INPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT"
    echo -e "${GREEN}已确保 SSH 端口 $ssh_port/tcp 放行${NC}"
    read -p "按回车键继续..."
}

del_accept() {
    read -p "请输入要删除放行的端口号（可多个，空格分隔）: " -a ports
    if [ ${#ports[@]} -eq 0 ]; then
        echo -e "${RED}未输入端口${NC}"
        read -p "按回车键继续..."
        return
    fi

    echo "请选择要删除的协议："
    echo "1) TCP  only"
    echo "2) UDP  only"
    echo "3) TCP+UDP (both)"
    read -p "选择 [1-3] (默认 3): " proto_choice
    proto_choice=${proto_choice:-3}

    case $proto_choice in
        1) protos=("tcp") ;;
        2) protos=("udp") ;;
        3) protos=("tcp" "udp") ;;
        *) echo -e "${RED}无效选择，默认使用 TCP+UDP${NC}"; protos=("tcp" "udp") ;;
    esac

    ssh_port=$(get_ssh_port)
    for port in "${ports[@]}"; do
        if ! [[ "$port" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}跳过无效端口 $port${NC}"
            continue
        fi
        for proto in "${protos[@]}"; do
            # 阻止删除 SSH 端口规则
            if [ "$port" = "$ssh_port" ] && [ "$proto" = "tcp" ]; then
                echo -e "${YELLOW}警告：SSH 端口 $ssh_port/tcp 不能被删除，已自动跳过。${NC}"
                continue
            fi
            if iptables -D INPUT -p $proto --dport $port -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null; then
                echo -e "${GREEN}已删除放行端口 $port/$proto${NC}"
            else
                echo -e "${YELLOW}未找到 $port/$proto 放行规则${NC}"
            fi
        done
    done
    read -p "按回车键继续..."
}

# 修改拒绝端口
modify_drop() {
    clear
    echo -e "${BLUE}--- 修改拒绝端口 ---${NC}"
    echo "当前拒绝规则（包含 DROP）："
    iptables -L INPUT -v -n --line-numbers | grep DROP | grep -E -- 'dpt:|spt:' || echo "无拒绝规则"
    echo ""
    echo "请选择操作："
    echo "1. 增加拒绝端口"
    echo "2. 删除拒绝端口"
    echo "0. 返回"
    read -p "选择: " op
    case $op in
        1) add_drop ;;
        2) del_drop ;;
        0) return ;;
        *) echo -e "${RED}无效选择${NC}"; sleep 1 ;;
    esac
}

add_drop() {
    read -p "请输入要拒绝的端口号（可多个，空格分隔）: " -a ports
    if [ ${#ports[@]} -eq 0 ]; then
        echo -e "${RED}未输入端口${NC}"
        read -p "按回车键继续..."
        return
    fi

    echo "请选择协议："
    echo "1) TCP  only"
    echo "2) UDP  only"
    echo "3) TCP+UDP (both)"
    read -p "选择 [1-3] (默认 3): " proto_choice
    proto_choice=${proto_choice:-3}

    case $proto_choice in
        1) protos=("tcp") ;;
        2) protos=("udp") ;;
        3) protos=("tcp" "udp") ;;
        *) echo -e "${RED}无效选择，默认使用 TCP+UDP${NC}"; protos=("tcp" "udp") ;;
    esac

    ssh_port=$(get_ssh_port)
    for port in "${ports[@]}"; do
        if ! [[ "$port" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}跳过无效端口 $port${NC}"
            continue
        fi
        # 阻止拒绝 SSH 端口
        if [ "$port" = "$ssh_port" ]; then
            echo -e "${RED}错误：不能拒绝 SSH 端口 $ssh_port，操作已跳过。${NC}"
            continue
        fi
        for proto in "${protos[@]}"; do
            if iptables -C INPUT -p $proto --dport $port -j DROP -m comment --comment "$COMMENT" 2>/dev/null; then
                echo -e "${YELLOW}端口 $port/$proto 已存在拒绝规则${NC}"
            else
                iptables -I INPUT -p $proto --dport $port -j DROP -m comment --comment "$COMMENT"
                echo -e "${GREEN}已添加拒绝端口 $port/$proto${NC}"
            fi
        done
    done
    read -p "按回车键继续..."
}

del_drop() {
    read -p "请输入要删除拒绝的端口号（可多个，空格分隔）: " -a ports
    if [ ${#ports[@]} -eq 0 ]; then
        echo -e "${RED}未输入端口${NC}"
        read -p "按回车键继续..."
        return
    fi

    echo "请选择要删除的协议："
    echo "1) TCP  only"
    echo "2) UDP  only"
    echo "3) TCP+UDP (both)"
    read -p "选择 [1-3] (默认 3): " proto_choice
    proto_choice=${proto_choice:-3}

    case $proto_choice in
        1) protos=("tcp") ;;
        2) protos=("udp") ;;
        3) protos=("tcp" "udp") ;;
        *) echo -e "${RED}无效选择，默认使用 TCP+UDP${NC}"; protos=("tcp" "udp") ;;
    esac

    for port in "${ports[@]}"; do
        if ! [[ "$port" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}跳过无效端口 $port${NC}"
            continue
        fi
        for proto in "${protos[@]}"; do
            if iptables -D INPUT -p $proto --dport $port -j DROP -m comment --comment "$COMMENT" 2>/dev/null; then
                echo -e "${GREEN}已删除拒绝端口 $port/$proto${NC}"
            else
                echo -e "${YELLOW}未找到 $port/$proto 拒绝规则${NC}"
            fi
        done
    done
    read -p "按回车键继续..."
}

# 新增：一键拒绝所有入站
set_default_drop_in() {
    clear
    echo -e "${YELLOW}警告：即将设置 INPUT 链默认策略为 DROP，所有入站连接将被拒绝，但会自动放行 SSH 端口。${NC}"
    echo -e "${YELLOW}请确保您理解此操作的影响。${NC}"
    read -p "确认继续？[y/N]: " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "已取消。"
        read -p "按回车键继续..."
        return
    fi

    ssh_port=$(get_ssh_port)
    echo -e "${GREEN}1. 确保 SSH 端口 $ssh_port 已放行...${NC}"
    iptables -C INPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null || \
        iptables -I INPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT"
    echo -e "${GREEN}2. 设置 INPUT 链默认策略为 DROP...${NC}"
    iptables -P INPUT DROP
    echo -e "${GREEN}操作完成。${NC}"
    read -p "按回车键继续..."
}

# 新增：一键拒绝所有出站
set_default_drop_out() {
    clear
    echo -e "${YELLOW}警告：即将设置 OUTPUT 链默认策略为 DROP，所有出站连接将被拒绝，但会自动放行必要的连接以维持 SSH 会话。${NC}"
    echo -e "${YELLOW}将放行：已建立的连接、回环接口、SSH 出站（目标端口 $ssh_port）。${NC}"
    read -p "确认继续？[y/N]: " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "已取消。"
        read -p "按回车键继续..."
        return
    fi

    ssh_port=$(get_ssh_port)
    # 放行已建立的连接
    iptables -C OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null || \
        iptables -I OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment "$COMMENT"
    # 放行回环接口
    iptables -C OUTPUT -o lo -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null || \
        iptables -I OUTPUT -o lo -j ACCEPT -m comment --comment "$COMMENT"
    # 放行 SSH 出站（目标端口22）
    iptables -C OUTPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null || \
        iptables -I OUTPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT"
    echo -e "${GREEN}设置 OUTPUT 链默认策略为 DROP...${NC}"
    iptables -P OUTPUT DROP
    echo -e "${GREEN}操作完成。${NC}"
    read -p "按回车键继续..."
}

# 彻底卸载
uninstall_script() {
    clear
    echo -e "${RED}警告：此操作将彻底卸载 $SCRIPT_NAME，并删除所有相关配置和 iptables 规则。${NC}"
    echo "但会保留 SSH 端口 ($(get_ssh_port)) 的放行规则（如果存在）。"
    read -p "确认卸载？[y/N]: " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "取消卸载。"
        return
    fi

    if [ -f "$PID_FILE" ]; then
        kill $(cat "$PID_FILE") 2>/dev/null || true
        rm -f "$PID_FILE"
    fi

    echo "正在清理 iptables 规则..."
    iptables -F TRAFFIC_IN 2>/dev/null || true
    iptables -F TRAFFIC_OUT 2>/dev/null || true
    iptables -D INPUT -j TRAFFIC_IN 2>/dev/null || true
    iptables -D OUTPUT -j TRAFFIC_OUT 2>/dev/null || true
    iptables -X TRAFFIC_IN 2>/dev/null || true
    iptables -X TRAFFIC_OUT 2>/dev/null || true

    ssh_port=$(get_ssh_port)
    iptables-save > /tmp/iptables.backup
    grep -v "$COMMENT" /tmp/iptables.backup | iptables-restore
    iptables -I INPUT -p tcp --dport $ssh_port -j ACCEPT 2>/dev/null || true

    rm -rf "$CONFIG_DIR"
    rm -f "$PID_FILE" "$LOG_FILE"

    echo -e "${GREEN}卸载完成。${NC}"
    rm -f "$0"
    exit 0
}

# ---------- 启动守护进程 ----------
start_daemon() {
    if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null; then
        return 0
    fi
    nohup "$0" --daemon >/dev/null 2>&1 &
    sleep 1
    if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null; then
        echo -e "${GREEN}守护进程已启动。${NC}"
    else
        echo -e "${RED}守护进程启动失败。${NC}"
    fi
}

# ---------- 主入口 ----------
main() {
    check_root
    init_config

    if [ "${1:-}" = "--daemon" ]; then
        daemon
        exit 0
    fi

    start_daemon
    main_menu
}

main "$@"