#!/bin/bash
export PATH=$PATH:/sbin:/usr/sbin
# lljb - 轻量级端口流量监控与防火墙管理工具
# 版本：1.1 (新增一键拒绝入站/出站功能)
# 作者：looopy66

set -euo pipefail

# ---------- 全局配置 ----------
readonly SCRIPT_NAME="lljb"
readonly CONFIG_DIR="/etc/lljb"
readonly PORTS_FILE="$CONFIG_DIR/ports.conf"
readonly TRAFFIC_FILE="$CONFIG_DIR/traffic.db"
readonly LAST_COUNTER_FILE="$CONFIG_DIR/last_counter"
readonly PID_FILE="/var/run/lljb.pid"
readonly LOG_FILE="/var/log/lljb.log"
readonly COMMENT="lljb-managed"
readonly DAEMON_INTERVAL=30
readonly TOTAL_FILE="$CONFIG_DIR/total.db"   # 如果已添加总流量功能

# ---------- 颜色输出 ----------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# ---------- 辅助函数 ----------
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

error_exit() {
    echo -e "${RED}错误：$1${NC}" >&2
    exit 1
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        error_exit "请以 root 权限运行此脚本。"
    fi
}

init_config() {
    mkdir -p "$CONFIG_DIR"
    touch "$PORTS_FILE" "$TRAFFIC_FILE" "$LAST_COUNTER_FILE" "$TOTAL_FILE" "$LOG_FILE"
}

# 获取 SSH 端口（从配置文件或默认22）
get_ssh_port() {
    local ssh_port=$(grep -E "^Port\s+" /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}' | head -1)
    echo "${ssh_port:-22}"
}

# ---------- iptables 操作 ----------
create_custom_chains() {
    # IPv4
    if ! iptables -L TRAFFIC_IN >/dev/null 2>&1; then
        iptables -N TRAFFIC_IN
        iptables -I INPUT -j TRAFFIC_IN
    fi
    if ! iptables -L TRAFFIC_OUT >/dev/null 2>&1; then
        iptables -N TRAFFIC_OUT
        iptables -I OUTPUT -j TRAFFIC_OUT
    fi

    # IPv6 (如果 ip6tables 可用)
    if command -v ip6tables >/dev/null 2>&1; then
        if ! ip6tables -L TRAFFIC_IN >/dev/null 2>&1; then
            ip6tables -N TRAFFIC_IN
            ip6tables -I INPUT -j TRAFFIC_IN
        fi
        if ! ip6tables -L TRAFFIC_OUT >/dev/null 2>&1; then
            ip6tables -N TRAFFIC_OUT
            ip6tables -I OUTPUT -j TRAFFIC_OUT
        fi
    fi
}

delete_custom_chains() {
    # IPv4
    iptables -D INPUT -j TRAFFIC_IN 2>/dev/null || true
    iptables -D OUTPUT -j TRAFFIC_OUT 2>/dev/null || true
    iptables -F TRAFFIC_IN 2>/dev/null || true
    iptables -F TRAFFIC_OUT 2>/dev/null || true
    iptables -X TRAFFIC_IN 2>/dev/null || true
    iptables -X TRAFFIC_OUT 2>/dev/null || true

    # IPv6
    if command -v ip6tables >/dev/null 2>&1; then
        ip6tables -D INPUT -j TRAFFIC_IN 2>/dev/null || true
        ip6tables -D OUTPUT -j TRAFFIC_OUT 2>/dev/null || true
        ip6tables -F TRAFFIC_IN 2>/dev/null || true
        ip6tables -F TRAFFIC_OUT 2>/dev/null || true
        ip6tables -X TRAFFIC_IN 2>/dev/null || true
        ip6tables -X TRAFFIC_OUT 2>/dev/null || true
    fi
}

# 添加监控端口规则（只计数，不干预）
add_monitor_rule() {
    local port=$1
    local proto=$2
    # IPv4
    iptables -A TRAFFIC_IN -p $proto --dport $port -m comment --comment "$COMMENT"
    iptables -A TRAFFIC_OUT -p $proto --sport $port -m comment --comment "$COMMENT"
    # IPv6
    if command -v ip6tables >/dev/null 2>&1; then
        ip6tables -A TRAFFIC_IN -p $proto --dport $port -m comment --comment "$COMMENT"
        ip6tables -A TRAFFIC_OUT -p $proto --sport $port -m comment --comment "$COMMENT"
    fi
    log "添加监控端口：$port/$proto (IPv4+IPv6)"
}

add_monitor_rule() {
    local port=$1
    local proto=$2
    # IPv4
    iptables -A TRAFFIC_IN -p $proto --dport $port -m comment --comment "$COMMENT"
    iptables -A TRAFFIC_OUT -p $proto --sport $port -m comment --comment "$COMMENT"
    # IPv6
    if command -v ip6tables >/dev/null 2>&1; then
        ip6tables -A TRAFFIC_IN -p $proto --dport $port -m comment --comment "$COMMENT"
        ip6tables -A TRAFFIC_OUT -p $proto --sport $port -m comment --comment "$COMMENT"
    fi
    log "添加监控端口：$port/$proto (IPv4+IPv6)"
}

# 获取所有监控端口列表（从配置文件）
get_monitored_ports() {
    if [ -f "$PORTS_FILE" ]; then
        cat "$PORTS_FILE"
    fi
}

# 获取所有非回环接口的总入站和出站字节数
get_total_traffic() {
    local in=0 out=0
    while read -r line; do
        # 跳过标题行和回环接口
        [[ "$line" =~ ^[[:space:]]*face|^[[:space:]]*lo: ]] && continue
        if [[ "$line" =~ ^[[:space:]]*[^:]+:[[:space:]]*([0-9]+)[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+([0-9]+) ]]; then
            in=$((in + ${BASH_REMATCH[1]}))
            out=$((out + ${BASH_REMATCH[2]}))
        fi
    done < /proc/net/dev
    echo "$in $out"
}

# 获取所有端口的当前原始计数（字节）
get_raw_counters() {
    # IPv4 计数
    iptables -L TRAFFIC_IN -v -n -x | awk -v comment="$COMMENT" '
        $0 ~ comment && ($4=="tcp" || $4=="udp") {
            proto=$4
            for (i=1;i<=NF;i++) if ($i=="--dport") {port=$(i+1); break}
            if (port!="") print proto":in:"port":"$2
        }
    '
    iptables -L TRAFFIC_OUT -v -n -x | awk -v comment="$COMMENT" '
        $0 ~ comment && ($4=="tcp" || $4=="udp") {
            proto=$4
            for (i=1;i<=NF;i++) if ($i=="--sport") {port=$(i+1); break}
            if (port!="") print proto":out:"port":"$2
        }
    '

    # IPv6 计数（如果可用）
    if command -v ip6tables >/dev/null 2>&1; then
        ip6tables -L TRAFFIC_IN -v -n -x | awk -v comment="$COMMENT" '
            $0 ~ comment && ($4=="tcp" || $4=="udp") {
                proto=$4
                for (i=1;i<=NF;i++) if ($i=="--dport") {port=$(i+1); break}
                if (port!="") print proto":in:"port":"$2
            }
        '
        ip6tables -L TRAFFIC_OUT -v -n -x | awk -v comment="$COMMENT" '
            $0 ~ comment && ($4=="tcp" || $4=="udp") {
                proto=$4
                for (i=1;i<=NF;i++) if ($i=="--sport") {port=$(i+1); break}
                if (port!="") print proto":out:"port":"$2
            }
        '
    fi
}

# 字节数格式化
format_bytes() {
    local bytes=$1
    # 确保输入为数字
    if ! [[ "$bytes" =~ ^[0-9]+$ ]]; then
        bytes=0
    fi
    if [ $bytes -ge 1073741824 ]; then
        echo "$(echo "scale=2; $bytes/1073741824" | bc 2>/dev/null || echo "0.00")GB"
    elif [ $bytes -ge 1048576 ]; then
        echo "$(echo "scale=2; $bytes/1048576" | bc 2>/dev/null || echo "0.00")MB"
    elif [ $bytes -ge 1024 ]; then
        echo "$(echo "scale=2; $bytes/1024" | bc 2>/dev/null || echo "0.00")KB"
    else
        echo "${bytes}B"
    fi
}

# 获取当天0点的时间戳（秒）
get_today_midnight() {
    echo $(( $(date +%s) - $(date +%H)*3600 - $(date +%M)*60 - $(date +%S) ))
}

# ---------- 守护进程 ----------
daemon() {
    # 避免重复启动
    if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null; then
        exit 0
    fi
    echo $$ > "$PID_FILE"
    trap 'rm -f "$PID_FILE"; exit' EXIT INT TERM

    # 初始化配置目录和文件
    mkdir -p "$CONFIG_DIR"
    touch "$PORTS_FILE" "$TRAFFIC_FILE" "$LAST_COUNTER_FILE" "$TOTAL_FILE" "$LOG_FILE"

    # 创建自定义链（IPv4 + IPv6）
    create_custom_chains

    # 从配置文件加载监控端口，并确保规则存在
    while read -r port; do
        [ -z "$port" ] && continue
        add_monitor_rule "$port" tcp
        add_monitor_rule "$port" udp
    done < "$PORTS_FILE"

    # 初始化上次计数文件（如果不存在）
    if [ ! -s "$LAST_COUNTER_FILE" ]; then
        get_raw_counters > "$LAST_COUNTER_FILE"
        echo "TIMESTAMP=$(date +%s)" >> "$LAST_COUNTER_FILE"
        > "$TRAFFIC_FILE"
    fi

    # ---------- 总流量统计初始化 ----------
    # TOTAL_FILE 格式：累计入站 累计出站 上次原始入站 上次原始出站
    if [ ! -f "$TOTAL_FILE" ]; then
        echo "0 0 0 0" > "$TOTAL_FILE"
    fi

    # 获取当前总流量原始值
    get_total_traffic() {
        local in=0 out=0
        while read -r line; do
            # 跳过标题行和回环接口
            [[ "$line" =~ ^[[:space:]]*face|^[[:space:]]*lo: ]] && continue
            if [[ "$line" =~ ^[[:space:]]*[^:]+:[[:space:]]*([0-9]+)[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+[[:space:]]+([0-9]+) ]]; then
                in=$((in + ${BASH_REMATCH[1]}))
                out=$((out + ${BASH_REMATCH[2]}))
            fi
        done < /proc/net/dev
        echo "$in $out"
    }

    # ---------- 主循环 ----------
    while true; do
        sleep $DAEMON_INTERVAL

        # 获取当前原始端口计数
        current_raw=$(get_raw_counters)
        current_ts=$(date +%s)

        # 读取上次端口计数和时间戳
        if [ -f "$LAST_COUNTER_FILE" ]; then
            eval $(grep -E "^TIMESTAMP=" "$LAST_COUNTER_FILE")
            last_ts=${TIMESTAMP:-0}
            cp "$LAST_COUNTER_FILE" "${LAST_COUNTER_FILE}.old"
        else
            last_ts=0
            continue
        fi

        # 计算今天的零点时间戳（用于判断跨天）
        today_midnight=$(get_today_midnight)

        # ---------- 总流量统计 ----------
        # 读取 TOTAL_FILE
        read -r total_accum_in total_accum_out last_raw_in last_raw_out < "$TOTAL_FILE"
        # 获取当前原始总流量
        read -r curr_raw_in curr_raw_out <<< $(get_total_traffic)

        # 判断是否跨天
        if [ $last_ts -lt $today_midnight ]; then
            # 跨天：重置累计值，并用当前原始值作为新的基准
            total_accum_in=0
            total_accum_out=0
            last_raw_in=$curr_raw_in
            last_raw_out=$curr_raw_out
            log "总流量跨天重置"
        else
            # 非跨天：计算增量
            delta_in=$((curr_raw_in - last_raw_in))
            delta_out=$((curr_raw_out - last_raw_out))
            if [ $delta_in -lt 0 ] || [ $delta_out -lt 0 ]; then
                # 可能是计数器回绕或数据异常，重置基准
                log "总流量计数器异常，重置基准"
                last_raw_in=$curr_raw_in
                last_raw_out=$curr_raw_out
            else
                total_accum_in=$((total_accum_in + delta_in))
                total_accum_out=$((total_accum_out + delta_out))
                last_raw_in=$curr_raw_in
                last_raw_out=$curr_raw_out
            fi
        fi
        # 写入更新后的累计值和基准值
        echo "$total_accum_in $total_accum_out $last_raw_in $last_raw_out" > "$TOTAL_FILE"

        # ---------- 端口流量统计（原有逻辑，但跨天判断改用 today_midnight）----------
        if [ $last_ts -lt $today_midnight ]; then
            # 跨天：重置端口流量文件
            > "$TRAFFIC_FILE"
            echo "$current_raw" > "$LAST_COUNTER_FILE"
            echo "TIMESTAMP=$current_ts" >> "$LAST_COUNTER_FILE"
            continue
        fi

        # 解析当前端口计数
        declare -A current_in current_out
        while IFS=: read -r proto dir port bytes; do
            if [ "$dir" = "in" ]; then
                current_in["$proto:$port"]=$bytes
            else
                current_out["$proto:$port"]=$bytes
            fi
        done <<< "$current_raw"

        # 解析上次端口计数
        declare -A last_in last_out
        while IFS=: read -r proto dir port bytes; do
            if [ "$dir" = "in" ]; then
                last_in["$proto:$port"]=$bytes
            else
                last_out["$proto:$port"]=$bytes
            fi
        done < <(grep -v "^TIMESTAMP=" "${LAST_COUNTER_FILE}.old")

        # 计算增量并更新端口流量文件
        > "${TRAFFIC_FILE}.tmp"
        for key in "${!current_in[@]}"; do
            proto=${key%%:*}
            port=${key#*:}
            last_bytes=${last_in[$key]:-0}
            current_bytes=${current_in[$key]:-0}
            delta=$((current_bytes - last_bytes))
            if [ $delta -gt 0 ]; then
                old_total=$(grep "^${proto}:${port}:in:" "$TRAFFIC_FILE" | cut -d: -f4)
                old_total=${old_total:-0}
                new_total=$((old_total + delta))
                echo "${proto}:${port}:in:${new_total}" >> "${TRAFFIC_FILE}.tmp"
            fi
        done
        for key in "${!current_out[@]}"; do
            proto=${key%%:*}
            port=${key#*:}
            last_bytes=${last_out[$key]:-0}
            current_bytes=${current_out[$key]:-0}
            delta=$((current_bytes - last_bytes))
            if [ $delta -gt 0 ]; then
                old_total=$(grep "^${proto}:${port}:out:" "$TRAFFIC_FILE" | cut -d: -f4)
                old_total=${old_total:-0}
                new_total=$((old_total + delta))
                echo "${proto}:${port}:out:${new_total}" >> "${TRAFFIC_FILE}.tmp"
            fi
        done

        if [ -s "${TRAFFIC_FILE}.tmp" ]; then
            cat "${TRAFFIC_FILE}.tmp" > "$TRAFFIC_FILE"
        fi
        rm -f "${TRAFFIC_FILE}.tmp"

        # 更新上次计数文件
        echo "$current_raw" > "$LAST_COUNTER_FILE"
        echo "TIMESTAMP=$current_ts" >> "$LAST_COUNTER_FILE"
        rm -f "${LAST_COUNTER_FILE}.old"
    done
}

# ---------- 菜单功能 ----------

# 显示主菜单
main_menu() {
    while true; do
        clear
        echo -e "${BLUE}=================================${NC}"
        echo -e "${GREEN}       l l j b   主菜单${NC}"
        echo -e "${BLUE}=================================${NC}"
        
        # ---------- 新增：显示监控端口 ----------
        monitored_ports=$(get_monitored_ports | tr '\n' ' ')
        if [ -n "$monitored_ports" ]; then
            echo -e "${YELLOW}当前监控端口:${NC} $monitored_ports"
        else
            echo -e "${YELLOW}当前监控端口:${NC} 无"
        fi
        echo ""
        # ---------------------------------------

        echo "1. 显示监听端口流量使用量"
        echo "2. 显示总流量使用量"
        echo "3. 增加监听端口"
        echo "4. 删除监听端口"
        echo "5. 彻底卸载脚本"
        echo "6. 配置防火墙"
        echo "0. 退出"
        echo -e "${BLUE}=================================${NC}"
        read -p "请选择 [0-6]: " choice
        case $choice in
            1) show_port_traffic ;;
            2) show_total_traffic ;;
            3) add_port ;;
            4) remove_port ;;
            5) uninstall_script ;;
            6) firewall_menu ;;
            0) exit 0 ;;
            *) echo -e "${RED}无效选择，请重试${NC}"; sleep 1 ;;
        esac
    done
}

# 显示单个端口流量
show_port_traffic() {
    clear
    echo -e "${BLUE}--- 监听端口流量使用量 (当日累计) ---${NC}"
    if [ ! -f "$TRAFFIC_FILE" ] || [ ! -s "$TRAFFIC_FILE" ]; then
        echo "暂无流量数据。"
    else
        printf "%-10s %-8s %-15s %-15s\n" "端口" "协议" "下载(入站)" "上传(出站)"
        echo "----------------------------------------"
        declare -A in_map out_map
        while IFS=: read -r proto dir port bytes; do
            if [ "$dir" = "in" ]; then
                in_map["$port:$proto"]=$bytes
            else
                out_map["$port:$proto"]=$bytes
            fi
        done < "$TRAFFIC_FILE"
        monitored=$(get_monitored_ports)
        all_ports=$(echo -e "$monitored\n${!in_map[@]}" | tr ' ' '\n' | sort -un)
        for entry in $all_ports; do
            if [[ "$entry" =~ ^[0-9]+$ ]]; then
                port=$entry
                for proto in tcp udp; do
                    in_bytes=${in_map["$port:$proto"]:-0}
                    out_bytes=${out_map["$port:$proto"]:-0}
                    if [ $in_bytes -gt 0 ] || [ $out_bytes -gt 0 ]; then
                        printf "%-10s %-8s %-15s %-15s\n" "$port" "$proto" "$(format_bytes $in_bytes)" "$(format_bytes $out_bytes)"
                    fi
                done
            else
                IFS=':' read -r port proto <<< "$entry"
                in_bytes=${in_map["$port:$proto"]:-0}
                out_bytes=${out_map["$port:$proto"]:-0}
                printf "%-10s %-8s %-15s %-15s\n" "$port" "$proto" "$(format_bytes $in_bytes)" "$(format_bytes $out_bytes)"
            fi
        done
    fi
    echo ""
    read -p "按回车键返回菜单..."
}

# 显示总流量
show_total_traffic() {
    clear
    echo -e "${BLUE}--- 主机总流量使用量 (当日累计) ---${NC}"
    local total_in=0
    local total_out=0
    if [ -f "$TOTAL_FILE" ] && [ -s "$TOTAL_FILE" ]; then
        # 读取文件，忽略可能的额外字段
        read -r total_in total_out _ < "$TOTAL_FILE" 2>/dev/null || true
    fi
    # 确保变量为有效数字
    total_in=${total_in:-0}
    total_out=${total_out:-0}
    # 防止非数字导致计算错误
    if ! [[ "$total_in" =~ ^[0-9]+$ ]]; then total_in=0; fi
    if ! [[ "$total_out" =~ ^[0-9]+$ ]]; then total_out=0; fi
    local total=$((total_in + total_out))
    echo "总下载(入站): $(format_bytes $total_in)"
    echo "总上传(出站): $(format_bytes $total_out)"
    echo "总计: $(format_bytes $total)"
    echo ""
    read -p "按回车键返回菜单..."
}

# 增加监听端口
add_port() {
    clear
    show_active_ports
    echo -e "${BLUE}--- 增加监听端口 ---${NC}"
    read -p "请输入要监控的端口号（可多个，用空格分隔）: " -a ports
    if [ ${#ports[@]} -eq 0 ]; then
        echo -e "${RED}未输入端口${NC}"
        sleep 1
        return
    fi
    for port in "${ports[@]}"; do
        if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
            echo -e "${RED}跳过无效端口: $port${NC}"
            continue
        fi
        if grep -qx "$port" "$PORTS_FILE" 2>/dev/null; then
            echo -e "${YELLOW}端口 $port 已在监控列表中${NC}"
            continue
        fi
        echo "$port" >> "$PORTS_FILE"
        add_monitor_rule "$port" tcp
        add_monitor_rule "$port" udp
        echo -e "${GREEN}端口 $port 已添加监控${NC}"
    done
    echo ""
    read -p "按回车键返回菜单..."
}

# 删除监听端口
remove_port() {
    clear
    echo -e "${BLUE}--- 删除监听端口 ---${NC}"
    monitored=$(get_monitored_ports)
    if [ -z "$monitored" ]; then
        echo "当前没有监控任何端口。"
    else
        echo "当前监控端口:"
        echo "$monitored" | nl
        read -p "请输入要删除的端口号（可多个，用空格分隔）: " -a ports
        for port in "${ports[@]}"; do
            if grep -qx "$port" "$PORTS_FILE"; then
                sed -i "/^$port$/d" "$PORTS_FILE"
                remove_monitor_rule "$port" tcp
                remove_monitor_rule "$port" udp
                echo -e "${GREEN}端口 $port 已删除${NC}"
            else
                echo -e "${YELLOW}端口 $port 不在监控列表中${NC}"
            fi
        done
    fi
    echo ""
    read -p "按回车键返回菜单..."
}

# 防火墙子菜单（新增选项4和5）
firewall_menu() {
    while true; do
        clear
        echo -e "${BLUE}--- 防火墙配置 ---${NC}"
        echo "1. 显示当前防火墙状态 (详细模式)"
        echo "2. 显示当前防火墙状态 (简洁模式)"
        echo "3. 修改放行端口（增加/删除）"
        echo "4. 修改拒绝端口（增加/删除）"
        echo "5. 一键拒绝所有入站 (自动放行SSH端口)"
        echo "6. 一键拒绝所有出站 (自动放行SSH端口)"
        echo "0. 返回主菜单"
        read -p "请选择 [0-6]: " fw_choice
        case $fw_choice in
            1) show_firewall_detail ;;   # 调用详细模式
            2) show_firewall_simple ;;    # 调用简洁模式
            3) modify_accept ;;
            4) modify_drop ;;
            5) set_default_drop_in ;;
            6) set_default_drop_out ;;
            0) return ;;
            *) echo -e "${RED}无效选择${NC}"; sleep 1 ;;
        esac
    done
}

# 显示防火墙状态
show_firewall() {
    clear
    echo -e "${BLUE}--- 当前防火墙规则 (INPUT链) ---${NC}"
    iptables -L INPUT -v -n --line-numbers | head -20
    echo ""
    echo -e "${BLUE}--- 当前防火墙规则 (OUTPUT链) ---${NC}"
    iptables -L OUTPUT -v -n --line-numbers | head -20
    echo ""
    read -p "按回车键返回..."
}
# 简洁显示函数（类似 ufw 风格）
show_firewall_simple() {
    clear
    echo -e "${BLUE}--- 防火墙状态 (简洁模式) ---${NC}"

    local input_policy=$(iptables -L INPUT -n | head -1 | awk '{print $4}' | tr -d ')')
    local output_policy=$(iptables -L OUTPUT -n | head -1 | awk '{print $4}' | tr -d ')')
    local forward_policy=$(iptables -L FORWARD -n | head -1 | awk '{print $4}' | tr -d ')')

    echo -e "${GREEN}状态:${NC} 激活"
    echo -e "${GREEN}默认策略:${NC} 入站: ${YELLOW}$input_policy${NC}, 出站: ${YELLOW}$output_policy${NC}, 转发: ${YELLOW}$forward_policy${NC}"
    echo

    echo -e "${GREEN}允许入站规则:${NC}"
    printf "%-25s %-10s %-20s\n" "To" "Action" "From"
    echo "------------------------- ---------- --------------------"

    iptables-save | grep '^-A INPUT' | while read -r rule; do
        if ! echo "$rule" | grep -q -- '-j ACCEPT'; then
            continue
        fi
        local proto=""
        local dport=""
        local multiport=""
        local source="Anywhere"
        if [[ "$rule" =~ -s[[:space:]]+([^[:space:]]+) ]]; then
            source="${BASH_REMATCH[1]}"
        fi
        if [[ "$rule" =~ -m[[:space:]]+multiport[[:space:]]+--dports[[:space:]]+([0-9,:]+) ]]; then
            multiport="${BASH_REMATCH[1]}"
            if [[ "$rule" =~ -p[[:space:]]+([a-z]+) ]]; then
                proto="${BASH_REMATCH[1]}"
            else
                proto="tcp/udp"
            fi
            dport="$multiport"
        else
            if [[ "$rule" =~ -p[[:space:]]+([a-z]+) ]]; then
                proto="${BASH_REMATCH[1]}"
            fi
            if [[ "$rule" =~ --dport[[:space:]]+([0-9]+) ]]; then
                dport="${BASH_REMATCH[1]}"
            fi
        fi
        if [ -n "$proto" ] && [ -n "$dport" ]; then
            printf "%-25s %-10s %-20s\n" "${dport}/${proto}" "ALLOW" "$source"
        fi
    done

    echo
    echo -e "${GREEN}拒绝入站规则:${NC}"
    printf "%-25s %-10s %-20s\n" "To" "Action" "From"
    echo "------------------------- ---------- --------------------"

    iptables-save | grep '^-A INPUT' | while read -r rule; do
        if ! echo "$rule" | grep -q -- '-j DROP'; then
            continue
        fi
        local proto=""
        local dport=""
        local multiport=""
        local source="Anywhere"
        if [[ "$rule" =~ -s[[:space:]]+([^[:space:]]+) ]]; then
            source="${BASH_REMATCH[1]}"
        fi
        if [[ "$rule" =~ -m[[:space:]]+multiport[[:space:]]+--dports[[:space:]]+([0-9,:]+) ]]; then
            multiport="${BASH_REMATCH[1]}"
            if [[ "$rule" =~ -p[[:space:]]+([a-z]+) ]]; then
                proto="${BASH_REMATCH[1]}"
            else
                proto="tcp/udp"
            fi
            dport="$multiport"
        else
            if [[ "$rule" =~ -p[[:space:]]+([a-z]+) ]]; then
                proto="${BASH_REMATCH[1]}"
            fi
            if [[ "$rule" =~ --dport[[:space:]]+([0-9]+) ]]; then
                dport="${BASH_REMATCH[1]}"
            fi
        fi
        if [ -n "$proto" ] && [ -n "$dport" ]; then
            printf "%-25s %-10s %-20s\n" "${dport}/${proto}" "DENY" "$source"
        fi
    done

    echo
    echo -e "${YELLOW}提示：仅显示 TCP/UDP 端口规则，复杂规则可能未完全列出。${NC}"
    echo ""
    read -p "按回车键返回..."
}

# 显示当前活跃端口及进程（跨平台版）
show_active_ports() {
    echo -e "${BLUE}--- 当前活跃端口及进程 ---${NC}"
    printf "%-8s %-8s %-12s %-8s %s\n" "协议" "端口" "状态" "PID" "进程名"

    # 获取所有监听端口 (LISTEN)
    ss -tulnp | awk 'NR>1 {
        split($5, addr, ":");
        port = addr[length(addr)];
        proto = $1;
        state = "LISTEN";
        pid_info = $7;
        pid = "-"; proc = "-";
        # 提取 PID
        if (pid_info ~ /pid=/) {
            gsub(/.*pid=/, "", pid_info);
            split(pid_info, a, ",");
            pid = a[1];
        }
        # 提取进程名（按双引号分割，取第二个字段）
        pid_info = $7;
        if (pid_info ~ /users:/) {
            n = split(pid_info, arr, "\"");
            if (n >= 2) proc = arr[2];
        }
        printf "%-8s %-8s %-12s %-8s %s\n", proto, port, state, pid, proc;
    }'

    # 获取已建立的连接 (ESTAB)
    ss -tpn | awk '/ESTAB/ {
        split($5, addr, ":");
        port = addr[length(addr)];
        proto = $1;
        state = "ESTAB";
        pid_info = $6;
        pid = "-"; proc = "-";
        if (pid_info ~ /pid=/) {
            gsub(/.*pid=/, "", pid_info);
            split(pid_info, a, ",");
            pid = a[1];
        }
        pid_info = $6;
        if (pid_info ~ /users:/) {
            n = split(pid_info, arr, "\"");
            if (n >= 2) proc = arr[2];
        }
        printf "%-8s %-8s %-12s %-8s %s\n", proto, port, state, pid, proc;
    }' | sort -u

    echo "----------------------------------------"
    echo -e "${YELLOW}提示：部分进程可能无法显示，可使用 'lsof -i :端口号' 手动查询。${NC}"
}

# 修改放行端口
modify_accept() {
    clear
    show_active_ports
    echo -e "${BLUE}--- 修改放行端口 ---${NC}"
    echo "当前放行规则（包含 ACCEPT）："
    iptables -L INPUT -v -n --line-numbers | grep ACCEPT | grep -E -- 'dpt:|spt:' || echo "无放行规则"
    echo ""
    echo "请选择操作："
    echo "1. 增加放行端口"
    echo "2. 删除放行端口"
    echo "0. 返回"
    read -p "选择: " op
    case $op in
        1) add_accept ;;
        2) del_accept ;;
        0) return ;;
        *) echo -e "${RED}无效选择${NC}"; sleep 1 ;;
    esac
}

add_accept() {
    read -p "请输入要放行的端口号（可多个，空格分隔）: " -a ports
    if [ ${#ports[@]} -eq 0 ]; then
        echo -e "${RED}未输入端口${NC}"
        read -p "按回车键继续..."
        return
    fi

    echo "请选择协议："
    echo "1) TCP  only"
    echo "2) UDP  only"
    echo "3) TCP+UDP (both)"
    read -p "选择 [1-3] (默认 3): " proto_choice
    proto_choice=${proto_choice:-3}

    case $proto_choice in
        1) protos=("tcp") ;;
        2) protos=("udp") ;;
        3) protos=("tcp" "udp") ;;
        *) echo -e "${RED}无效选择，默认使用 TCP+UDP${NC}"; protos=("tcp" "udp") ;;
    esac

    for port in "${ports[@]}"; do
        if ! [[ "$port" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}跳过无效端口 $port${NC}"
            continue
        fi
        for proto in "${protos[@]}"; do
            if iptables -C INPUT -p $proto --dport $port -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null; then
                echo -e "${YELLOW}端口 $port/$proto 已存在放行规则${NC}"
            else
                iptables -I INPUT -p $proto --dport $port -j ACCEPT -m comment --comment "$COMMENT"
                echo -e "${GREEN}已添加放行端口 $port/$proto${NC}"
            fi
        done
    done

    # 确保 SSH 端口放行（仅 TCP）
    ssh_port=$(get_ssh_port)
    iptables -C INPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null || \
        iptables -I INPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT"
    echo -e "${GREEN}已确保 SSH 端口 $ssh_port/tcp 放行${NC}"
    read -p "按回车键继续..."
}

del_accept() {
    read -p "请输入要删除放行的端口号（可多个，空格分隔）: " -a ports
    if [ ${#ports[@]} -eq 0 ]; then
        echo -e "${RED}未输入端口${NC}"
        read -p "按回车键继续..."
        return
    fi

    echo "请选择要删除的协议："
    echo "1) TCP  only"
    echo "2) UDP  only"
    echo "3) TCP+UDP (both)"
    read -p "选择 [1-3] (默认 3): " proto_choice
    proto_choice=${proto_choice:-3}

    case $proto_choice in
        1) protos=("tcp") ;;
        2) protos=("udp") ;;
        3) protos=("tcp" "udp") ;;
        *) echo -e "${RED}无效选择，默认使用 TCP+UDP${NC}"; protos=("tcp" "udp") ;;
    esac

    ssh_port=$(get_ssh_port)
    for port in "${ports[@]}"; do
        if ! [[ "$port" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}跳过无效端口 $port${NC}"
            continue
        fi
        for proto in "${protos[@]}"; do
            # 阻止删除 SSH 端口规则
            if [ "$port" = "$ssh_port" ] && [ "$proto" = "tcp" ]; then
                echo -e "${YELLOW}警告：SSH 端口 $ssh_port/tcp 不能被删除，已自动跳过。${NC}"
                continue
            fi
            if iptables -D INPUT -p $proto --dport $port -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null; then
                echo -e "${GREEN}已删除放行端口 $port/$proto${NC}"
            else
                echo -e "${YELLOW}未找到 $port/$proto 放行规则${NC}"
            fi
        done
    done
    read -p "按回车键继续..."
}

# 修改拒绝端口
modify_drop() {
    clear
    show_active_ports
    echo -e "${BLUE}--- 修改拒绝端口 ---${NC}"
    echo "当前拒绝规则（包含 DROP）："
    iptables -L INPUT -v -n --line-numbers | grep DROP | grep -E -- 'dpt:|spt:' || echo "无拒绝规则"
    echo ""
    echo "请选择操作："
    echo "1. 增加拒绝端口"
    echo "2. 删除拒绝端口"
    echo "0. 返回"
    read -p "选择: " op
    case $op in
        1) add_drop ;;
        2) del_drop ;;
        0) return ;;
        *) echo -e "${RED}无效选择${NC}"; sleep 1 ;;
    esac
}

add_drop() {
    read -p "请输入要拒绝的端口号（可多个，空格分隔）: " -a ports
    if [ ${#ports[@]} -eq 0 ]; then
        echo -e "${RED}未输入端口${NC}"
        read -p "按回车键继续..."
        return
    fi

    echo "请选择协议："
    echo "1) TCP  only"
    echo "2) UDP  only"
    echo "3) TCP+UDP (both)"
    read -p "选择 [1-3] (默认 3): " proto_choice
    proto_choice=${proto_choice:-3}

    case $proto_choice in
        1) protos=("tcp") ;;
        2) protos=("udp") ;;
        3) protos=("tcp" "udp") ;;
        *) echo -e "${RED}无效选择，默认使用 TCP+UDP${NC}"; protos=("tcp" "udp") ;;
    esac

    ssh_port=$(get_ssh_port)
    for port in "${ports[@]}"; do
        if ! [[ "$port" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}跳过无效端口 $port${NC}"
            continue
        fi
        # 阻止拒绝 SSH 端口
        if [ "$port" = "$ssh_port" ]; then
            echo -e "${RED}错误：不能拒绝 SSH 端口 $ssh_port，操作已跳过。${NC}"
            continue
        fi
        for proto in "${protos[@]}"; do
            if iptables -C INPUT -p $proto --dport $port -j DROP -m comment --comment "$COMMENT" 2>/dev/null; then
                echo -e "${YELLOW}端口 $port/$proto 已存在拒绝规则${NC}"
            else
                iptables -I INPUT -p $proto --dport $port -j DROP -m comment --comment "$COMMENT"
                echo -e "${GREEN}已添加拒绝端口 $port/$proto${NC}"
            fi
        done
    done
    read -p "按回车键继续..."
}

del_drop() {
    read -p "请输入要删除拒绝的端口号（可多个，空格分隔）: " -a ports
    if [ ${#ports[@]} -eq 0 ]; then
        echo -e "${RED}未输入端口${NC}"
        read -p "按回车键继续..."
        return
    fi

    echo "请选择要删除的协议："
    echo "1) TCP  only"
    echo "2) UDP  only"
    echo "3) TCP+UDP (both)"
    read -p "选择 [1-3] (默认 3): " proto_choice
    proto_choice=${proto_choice:-3}

    case $proto_choice in
        1) protos=("tcp") ;;
        2) protos=("udp") ;;
        3) protos=("tcp" "udp") ;;
        *) echo -e "${RED}无效选择，默认使用 TCP+UDP${NC}"; protos=("tcp" "udp") ;;
    esac

    for port in "${ports[@]}"; do
        if ! [[ "$port" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}跳过无效端口 $port${NC}"
            continue
        fi
        for proto in "${protos[@]}"; do
            if iptables -D INPUT -p $proto --dport $port -j DROP -m comment --comment "$COMMENT" 2>/dev/null; then
                echo -e "${GREEN}已删除拒绝端口 $port/$proto${NC}"
            else
                echo -e "${YELLOW}未找到 $port/$proto 拒绝规则${NC}"
            fi
        done
    done
    read -p "按回车键继续..."
}

# 新增：一键拒绝所有入站
set_default_drop_in() {
    clear
    echo -e "${YELLOW}警告：即将设置 INPUT 链默认策略为 DROP，所有入站连接将被拒绝，但会自动放行 SSH 端口。${NC}"
    echo -e "${YELLOW}请确保您理解此操作的影响。${NC}"
    read -p "确认继续？[y/N]: " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "已取消。"
        read -p "按回车键继续..."
        return
    fi

    ssh_port=$(get_ssh_port)
    echo -e "${GREEN}1. 确保 SSH 端口 $ssh_port 已放行...${NC}"
    iptables -C INPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null || \
        iptables -I INPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT"
    echo -e "${GREEN}2. 设置 INPUT 链默认策略为 DROP...${NC}"
    iptables -P INPUT DROP
    echo -e "${GREEN}操作完成。${NC}"
    read -p "按回车键继续..."
}

# 新增：一键拒绝所有出站
set_default_drop_out() {
    clear
    echo -e "${YELLOW}警告：即将设置 OUTPUT 链默认策略为 DROP，所有出站连接将被拒绝，但会自动放行必要的连接以维持 SSH 会话。${NC}"
    echo -e "${YELLOW}将放行：已建立的连接、回环接口、SSH 出站（目标端口 $ssh_port）。${NC}"
    read -p "确认继续？[y/N]: " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "已取消。"
        read -p "按回车键继续..."
        return
    fi

    ssh_port=$(get_ssh_port)
    # 放行已建立的连接
    iptables -C OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null || \
        iptables -I OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment "$COMMENT"
    # 放行回环接口
    iptables -C OUTPUT -o lo -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null || \
        iptables -I OUTPUT -o lo -j ACCEPT -m comment --comment "$COMMENT"
    # 放行 SSH 出站（目标端口22）
    iptables -C OUTPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT" 2>/dev/null || \
        iptables -I OUTPUT -p tcp --dport $ssh_port -j ACCEPT -m comment --comment "$COMMENT"
    echo -e "${GREEN}设置 OUTPUT 链默认策略为 DROP...${NC}"
    iptables -P OUTPUT DROP
    echo -e "${GREEN}操作完成。${NC}"
    read -p "按回车键继续..."
}

# 彻底卸载
uninstall_script() {
    clear
    echo -e "${RED}警告：此操作将彻底卸载 $SCRIPT_NAME，并删除所有相关配置和 iptables 规则。${NC}"
    echo "但会保留 SSH 端口 ($(get_ssh_port)) 的放行规则（如果存在）。"
    read -p "确认卸载？[y/N]: " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "取消卸载。"
        return
    fi

    if [ -f "$PID_FILE" ]; then
        kill $(cat "$PID_FILE") 2>/dev/null || true
        rm -f "$PID_FILE"
    fi

    echo "正在清理 iptables 规则..."
    iptables -F TRAFFIC_IN 2>/dev/null || true
    iptables -F TRAFFIC_OUT 2>/dev/null || true
    iptables -D INPUT -j TRAFFIC_IN 2>/dev/null || true
    iptables -D OUTPUT -j TRAFFIC_OUT 2>/dev/null || true
    iptables -X TRAFFIC_IN 2>/dev/null || true
    iptables -X TRAFFIC_OUT 2>/dev/null || true

    ssh_port=$(get_ssh_port)
    iptables-save > /tmp/iptables.backup
    grep -v "$COMMENT" /tmp/iptables.backup | iptables-restore
    iptables -I INPUT -p tcp --dport $ssh_port -j ACCEPT 2>/dev/null || true

    rm -rf "$CONFIG_DIR"
    rm -f "$PID_FILE" "$LOG_FILE"

    echo -e "${GREEN}卸载完成。${NC}"
    rm -f "$0"
    exit 0
}

# ---------- 启动守护进程 ----------
start_daemon() {
    if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null; then
        return 0
    fi
    nohup "$0" --daemon >/dev/null 2>&1 &
    sleep 1
    if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null; then
        echo -e "${GREEN}守护进程已启动。${NC}"
    else
        echo -e "${RED}守护进程启动失败。${NC}"
    fi
}

install_dependencies() {
    local missing=()

    # 检查必要命令（增加 ip6tables）
    for cmd in iptables ip6tables bc pgrep ss; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing+=("$cmd")
        fi
    done

    if [ ${#missing[@]} -eq 0 ]; then
        return 0
    fi

    echo -e "${YELLOW}检测到缺少依赖: ${missing[*]}，正在安装...${NC}"

    if [ -f /etc/alpine-release ]; then
        # Alpine 系统
        apk update
        for pkg in "${missing[@]}"; do
            case "$pkg" in
                ss)            apk add iproute2 ;;
                iptables|ip6tables) apk add iptables ;;  # ip6tables 也由 iptables 包提供
                bc)            apk add bc ;;
                pgrep)         apk add procps ;;
            esac
        done
    elif [ -f /etc/debian_version ]; then
        # Debian/Ubuntu 系统
        apt-get update -qq
        for pkg in "${missing[@]}"; do
            case "$pkg" in
                ss)            apt-get install -y iproute2 ;;
                iptables|ip6tables) apt-get install -y iptables ;;  # 统一安装 iptables 包
                bc)            apt-get install -y bc ;;
                pgrep)         apt-get install -y procps ;;
            esac
        done
    else
        echo -e "${RED}不支持的系统类型，请手动安装依赖: ${missing[*]}${NC}"
        exit 1
    fi

    echo -e "${GREEN}依赖安装完成${NC}"
}

# ---------- 主入口 ----------
main() {
    check_root
    install_dependencies
    init_config

    if [ "${1:-}" = "--daemon" ]; then
        daemon
        exit 0
    fi

    start_daemon
    main_menu
}

main "$@"
